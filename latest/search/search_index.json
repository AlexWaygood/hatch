{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hatch \u00b6 CI/CD Docs Package Meta Hatch is a modern, extensible Python project manager. Features \u00b6 Standardized build system with reproducible builds by default Robust environment management with support for custom scripts Easy publishing to PyPI or other sources Version management Configurable project generation with sane defaults Responsive CLI, ~2-3x faster than equivalent tools License \u00b6 Hatch is distributed under the terms of any of the following licenses: MIT Apache-2.0 Navigation \u00b6 Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"About"},{"location":"#hatch","text":"CI/CD Docs Package Meta Hatch is a modern, extensible Python project manager.","title":"Hatch"},{"location":"#features","text":"Standardized build system with reproducible builds by default Robust environment management with support for custom scripts Easy publishing to PyPI or other sources Version management Configurable project generation with sane defaults Responsive CLI, ~2-3x faster than equivalent tools","title":"Features"},{"location":"#license","text":"Hatch is distributed under the terms of any of the following licenses: MIT Apache-2.0","title":"License"},{"location":"#navigation","text":"Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"build/","text":"Builds \u00b6 Configuration \u00b6 Builds are configured using the tool.hatch.build table. Every target is defined by a section within tool.hatch.build.targets , for example: pyproject.toml hatch.toml [tool.hatch.build.targets.wheel] packages = [ \"src/foo\" ] [tool.hatch.build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ] [build.targets.wheel] packages = [ \"src/foo\" ] [build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ] Building \u00b6 Invoking the build command without any arguments will build all defined targets, each in an isolated environment: $ hatch build Setting up build environment... [sdist] dist/hatch_demo-1rc0.tar.gz Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl To only build specific targets, use the -t / --target option: $ hatch build -t wheel Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl If the target supports multiple versions , you can specify the exact versions to build by appending a colon followed by the desired versions separated by commas: $ hatch -v build -t wheel:standard Setting up build environment... ... [wheel] Building `wheel` version `standard` dist/hatch_demo-1rc0-py3-none-any.whl Packaging ecosystem \u00b6 Hatch complies with modern Python packaging specs and therefore your projects can be used by other tools with Hatch serving as just the build backend. So you could use tox as an alternative to Hatch's environment management , or cibuildwheel to distribute packages for every platform, and they both will transparently use Hatch without any extra modification.","title":"Builds"},{"location":"build/#builds","text":"","title":"Builds"},{"location":"build/#configuration","text":"Builds are configured using the tool.hatch.build table. Every target is defined by a section within tool.hatch.build.targets , for example: pyproject.toml hatch.toml [tool.hatch.build.targets.wheel] packages = [ \"src/foo\" ] [tool.hatch.build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ] [build.targets.wheel] packages = [ \"src/foo\" ] [build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ]","title":"Configuration"},{"location":"build/#building","text":"Invoking the build command without any arguments will build all defined targets, each in an isolated environment: $ hatch build Setting up build environment... [sdist] dist/hatch_demo-1rc0.tar.gz Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl To only build specific targets, use the -t / --target option: $ hatch build -t wheel Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl If the target supports multiple versions , you can specify the exact versions to build by appending a colon followed by the desired versions separated by commas: $ hatch -v build -t wheel:standard Setting up build environment... ... [wheel] Building `wheel` version `standard` dist/hatch_demo-1rc0-py3-none-any.whl","title":"Building"},{"location":"build/#packaging-ecosystem","text":"Hatch complies with modern Python packaging specs and therefore your projects can be used by other tools with Hatch serving as just the build backend. So you could use tox as an alternative to Hatch's environment management , or cibuildwheel to distribute packages for every platform, and they both will transparently use Hatch without any extra modification.","title":"Packaging ecosystem"},{"location":"environment/","text":"Environments \u00b6 Environments are designed to allow for isolated workspaces for testing, building documentation, or anything else projects need. Unless an environment is chosen explicitly, Hatch will use the default environment. Creation \u00b6 You can create environments by using the env create command. Let's enter the directory of the project we created in the setup phase : $ hatch env create Creating environment: default Installing project in development mode... Syncing dependencies... Tip You never need to manually create environments as spawning a shell or running commands within one will automatically trigger creation. Entering environments \u00b6 You can spawn a shell within an environment by using the shell command. $ hatch shell (hatch-demo) $ Now confirm the project has been installed: (hatch-demo) $ pip show hatch-demo Name: hatch-demo Version: 0.0.1 ... Finally, see where your environment's Python is located : (hatch-demo) $ python -c \"import sys;print(sys.executable)\" ... You can type exit to leave the environment. Command execution \u00b6 The run command allows you to execute commands in an environment as if you had already entered it. For example, running the following command will output the same path as before: hatch run python -c \"import sys;print(sys.executable)\" Scripts \u00b6 You can also run any scripts that have been defined. You'll notice that in the pyproject.toml file there are already scripts defined in the default environment. Try running the test command, which invokes pytest with some flags for tracking coverage : hatch run test All additional arguments are passed through to scripts, so for example if you wanted to see the version of pytest and which plugins are installed you could do: hatch run test -VV Dependencies \u00b6 Hatch ensures that environments are always compatible with the currently defined project dependencies (if installed and in dev mode ) and environment dependencies . For example, add cowsay as a dependency then try to run it: $ hatch run cowsay \"Hello, world!\" Syncing dependencies... _____________ | Hello, world! | ============= \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Selection \u00b6 You can select which environment to enter or run commands in by using the -e / --env root option or by setting the HATCH_ENV environment variable. The run command allows for more explicit selection by prepending <ENV_NAME>: to commands. For example, if you had the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" [envs.docs] dependencies = [ \"mkdocs\" ] [envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" you could then serve your documentation by running: hatch run docs:serve Tip If you've already entered an environment, commands will target it by default. Matrix \u00b6 Every environment can define its own set of matrices : pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"pytest\" ] [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[tool.hatch.envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] [envs.test] dependencies = [ \"pytest\" ] [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] Using the env show command would then display: $ hatch env show default [test] py27-42 py27-3.14 py38-42 py38-3.14 py38-9000-foo py38-9000-bar py39-9000-foo py39-9000-bar Removal \u00b6 You can remove a single environment or environment matrix by using the env remove command or all of a project's environments by using the env prune command.","title":"Environments"},{"location":"environment/#environments","text":"Environments are designed to allow for isolated workspaces for testing, building documentation, or anything else projects need. Unless an environment is chosen explicitly, Hatch will use the default environment.","title":"Environments"},{"location":"environment/#creation","text":"You can create environments by using the env create command. Let's enter the directory of the project we created in the setup phase : $ hatch env create Creating environment: default Installing project in development mode... Syncing dependencies... Tip You never need to manually create environments as spawning a shell or running commands within one will automatically trigger creation.","title":"Creation"},{"location":"environment/#entering-environments","text":"You can spawn a shell within an environment by using the shell command. $ hatch shell (hatch-demo) $ Now confirm the project has been installed: (hatch-demo) $ pip show hatch-demo Name: hatch-demo Version: 0.0.1 ... Finally, see where your environment's Python is located : (hatch-demo) $ python -c \"import sys;print(sys.executable)\" ... You can type exit to leave the environment.","title":"Entering environments"},{"location":"environment/#command-execution","text":"The run command allows you to execute commands in an environment as if you had already entered it. For example, running the following command will output the same path as before: hatch run python -c \"import sys;print(sys.executable)\"","title":"Command execution"},{"location":"environment/#scripts","text":"You can also run any scripts that have been defined. You'll notice that in the pyproject.toml file there are already scripts defined in the default environment. Try running the test command, which invokes pytest with some flags for tracking coverage : hatch run test All additional arguments are passed through to scripts, so for example if you wanted to see the version of pytest and which plugins are installed you could do: hatch run test -VV","title":"Scripts"},{"location":"environment/#dependencies","text":"Hatch ensures that environments are always compatible with the currently defined project dependencies (if installed and in dev mode ) and environment dependencies . For example, add cowsay as a dependency then try to run it: $ hatch run cowsay \"Hello, world!\" Syncing dependencies... _____________ | Hello, world! | ============= \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||","title":"Dependencies"},{"location":"environment/#selection","text":"You can select which environment to enter or run commands in by using the -e / --env root option or by setting the HATCH_ENV environment variable. The run command allows for more explicit selection by prepending <ENV_NAME>: to commands. For example, if you had the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" [envs.docs] dependencies = [ \"mkdocs\" ] [envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" you could then serve your documentation by running: hatch run docs:serve Tip If you've already entered an environment, commands will target it by default.","title":"Selection"},{"location":"environment/#matrix","text":"Every environment can define its own set of matrices : pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"pytest\" ] [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[tool.hatch.envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] [envs.test] dependencies = [ \"pytest\" ] [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] Using the env show command would then display: $ hatch env show default [test] py27-42 py27-3.14 py38-42 py38-3.14 py38-9000-foo py38-9000-bar py39-9000-foo py39-9000-bar","title":"Matrix"},{"location":"environment/#removal","text":"You can remove a single environment or environment matrix by using the env remove command or all of a project's environments by using the env prune command.","title":"Removal"},{"location":"install/","text":"Installation \u00b6 pipx \u00b6 pipx allows for the global installation of Python applications in isolated environments. pipx install hatch pip \u00b6 Hatch is available on PyPI and can be installed with pip . pip install --user hatch Warning This method modifies the Python environment in which you choose to install.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#pipx","text":"pipx allows for the global installation of Python applications in isolated environments. pipx install hatch","title":"pipx"},{"location":"install/#pip","text":"Hatch is available on PyPI and can be installed with pip . pip install --user hatch Warning This method modifies the Python environment in which you choose to install.","title":"pip"},{"location":"intro/","text":"Introduction \u00b6 Setup \u00b6 Projects can be setup for use by Hatch using the new command. New project \u00b6 Let's say you want to create a project named Hatch Demo . You would run: hatch new \"Hatch Demo\" This would create the following structure in your current working directory: hatch-demo \u251c\u2500\u2500 hatch_demo \u2502 \u251c\u2500\u2500 __about__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 tests \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 LICENSE.txt \u251c\u2500\u2500 README.md \u2514\u2500\u2500 pyproject.toml Tip If you intend for a project to have a command line interface, you can pass the --cli flag. Existing project \u00b6 To initialize an existing project, enter the directory containing the project and run the following: hatch new --init This will interactively guide you through the setup process. Project metadata \u00b6 Next you'll want to define more of your project's metadata located in the pyproject.toml file. You can specify things like its license , the supported versions of Python , and URLs referring to various parts of your project, like documentation. Dependencies \u00b6 The last step of the setup process is to define any dependencies that you'd like your project to begin with.","title":"Introduction"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#setup","text":"Projects can be setup for use by Hatch using the new command.","title":"Setup"},{"location":"intro/#new-project","text":"Let's say you want to create a project named Hatch Demo . You would run: hatch new \"Hatch Demo\" This would create the following structure in your current working directory: hatch-demo \u251c\u2500\u2500 hatch_demo \u2502 \u251c\u2500\u2500 __about__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 tests \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 LICENSE.txt \u251c\u2500\u2500 README.md \u2514\u2500\u2500 pyproject.toml Tip If you intend for a project to have a command line interface, you can pass the --cli flag.","title":"New project"},{"location":"intro/#existing-project","text":"To initialize an existing project, enter the directory containing the project and run the following: hatch new --init This will interactively guide you through the setup process.","title":"Existing project"},{"location":"intro/#project-metadata","text":"Next you'll want to define more of your project's metadata located in the pyproject.toml file. You can specify things like its license , the supported versions of Python , and URLs referring to various parts of your project, like documentation.","title":"Project metadata"},{"location":"intro/#dependencies","text":"The last step of the setup process is to define any dependencies that you'd like your project to begin with.","title":"Dependencies"},{"location":"next-steps/","text":"Next steps \u00b6 At this point you should have a basic understanding of how to use Hatch. Now you may want to check out advanced configuration for environments or builds , set up your preferred shell , or read more about Hatch's CLI . After that, if you see a need, feel free to write a plugin for extended functionality.","title":"Next steps"},{"location":"next-steps/#next-steps","text":"At this point you should have a basic understanding of how to use Hatch. Now you may want to check out advanced configuration for environments or builds , set up your preferred shell , or read more about Hatch's CLI . After that, if you see a need, feel free to write a plugin for extended functionality.","title":"Next steps"},{"location":"publish/","text":"Publishing \u00b6 After your project is built , you can distribute it using the publish command. The -p / --publisher option controls which publisher to use, with the default being pypi . Artifact selection \u00b6 By default, the dist directory located at the root of your project will be used: $ hatch publish dist/hatch_demo-1rc0-py3-none-any.whl ... success dist/hatch_demo-1rc0.tar.gz ... success [hatch-demo] https://pypi.org/project/hatch-demo/1rc0/ You can instead pass specific paths as arguments: hatch publish /path/to/artifacts foo-1.tar.gz Only files ending with .whl or .tar.gz will be published. Repository \u00b6 You can select the repository (package index) with which to upload using the -r / --repo option or by setting the HATCH_PYPI_REPO environment variable. Rather than specifying the full URL of a repository, you can use a named repository from a publish.pypi.repos table defined in Hatch's config file : config.toml [publish.pypi.repos] repo1 = \"url1\" ... The following repository names are reserved by Hatch and cannot be overriden: Name Repository main https://upload.pypi.org/legacy/ test https://test.pypi.org/legacy/ The main repository is used by default. Authentication \u00b6 The first time you publish to a repository you need to authenticate using the -u / --user (environment variable HATCH_PYPI_USER ) and -a / --auth (environment variable HATCH_PYPI_AUTH ) options. You will be prompted if either option is not provided. The user that most recently published to the chosen repository is cached , with their credentials saved to the system keyring , so that they will no longer need to provide authentication information. For automated releases, it is recommended that you use per-project API tokens .","title":"Publishing"},{"location":"publish/#publishing","text":"After your project is built , you can distribute it using the publish command. The -p / --publisher option controls which publisher to use, with the default being pypi .","title":"Publishing"},{"location":"publish/#artifact-selection","text":"By default, the dist directory located at the root of your project will be used: $ hatch publish dist/hatch_demo-1rc0-py3-none-any.whl ... success dist/hatch_demo-1rc0.tar.gz ... success [hatch-demo] https://pypi.org/project/hatch-demo/1rc0/ You can instead pass specific paths as arguments: hatch publish /path/to/artifacts foo-1.tar.gz Only files ending with .whl or .tar.gz will be published.","title":"Artifact selection"},{"location":"publish/#repository","text":"You can select the repository (package index) with which to upload using the -r / --repo option or by setting the HATCH_PYPI_REPO environment variable. Rather than specifying the full URL of a repository, you can use a named repository from a publish.pypi.repos table defined in Hatch's config file : config.toml [publish.pypi.repos] repo1 = \"url1\" ... The following repository names are reserved by Hatch and cannot be overriden: Name Repository main https://upload.pypi.org/legacy/ test https://test.pypi.org/legacy/ The main repository is used by default.","title":"Repository"},{"location":"publish/#authentication","text":"The first time you publish to a repository you need to authenticate using the -u / --user (environment variable HATCH_PYPI_USER ) and -a / --auth (environment variable HATCH_PYPI_AUTH ) options. You will be prompted if either option is not provided. The user that most recently published to the chosen repository is cached , with their credentials saved to the system keyring , so that they will no longer need to provide authentication information. For automated releases, it is recommended that you use per-project API tokens .","title":"Authentication"},{"location":"version/","text":"Versioning \u00b6 Configuration \u00b6 When the version is not statically set , configuration is defined in the tool.hatch.version table. The source option determines the source to use for retrieving and updating the version. The regex source is used by default. The regex source requires an option path that represents a relative path to a file containing the project's version: pyproject.toml hatch.toml [tool.hatch.version] path = \"hatch_demo/__about__.py\" [version] path = \"hatch_demo/__about__.py\" The default pattern looks for a variable named __version__ or VERSION that is set to a string containing the version, optionally prefixed with the lowercase letter v . If this doesn't reflect how you store the version, you can define a different regular expression using the pattern option: pyproject.toml hatch.toml [tool.hatch.version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" [version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" The pattern must have a named group called version that represents the version. Display \u00b6 Invoking the version command without any arguments will display the current version of the project: $ hatch version 0.0.1 Updating \u00b6 You can update the version like so: $ hatch version \"0.1.0\" Old: 0.0.1 New: 0.1 The scheme option determines the scheme to use for parsing both the existing and new versions. The standard scheme is used by default, which is based on PEP 440 . Rather than setting the version explicitly, you can select the name of a segment used to increment the version: $ hatch version minor Old: 0.1 New: 0.2 You can chain multiple segment updates with a comma. For example, if you wanted to release a preview of your project's first major version, you could do: $ hatch version major,rc Old: 0.2 New: 1rc0 Supported segments \u00b6 Here are the supported segments and how they would influence an existing version of 1 : Segments New version major 2 minor 1.1 micro patch fix 1.0.1 a alpha 1a0 b beta 1b0 c rc pre preview 1rc0 r rev post 1.post0 dev 1.dev0","title":"Versioning"},{"location":"version/#versioning","text":"","title":"Versioning"},{"location":"version/#configuration","text":"When the version is not statically set , configuration is defined in the tool.hatch.version table. The source option determines the source to use for retrieving and updating the version. The regex source is used by default. The regex source requires an option path that represents a relative path to a file containing the project's version: pyproject.toml hatch.toml [tool.hatch.version] path = \"hatch_demo/__about__.py\" [version] path = \"hatch_demo/__about__.py\" The default pattern looks for a variable named __version__ or VERSION that is set to a string containing the version, optionally prefixed with the lowercase letter v . If this doesn't reflect how you store the version, you can define a different regular expression using the pattern option: pyproject.toml hatch.toml [tool.hatch.version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" [version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" The pattern must have a named group called version that represents the version.","title":"Configuration"},{"location":"version/#display","text":"Invoking the version command without any arguments will display the current version of the project: $ hatch version 0.0.1","title":"Display"},{"location":"version/#updating","text":"You can update the version like so: $ hatch version \"0.1.0\" Old: 0.0.1 New: 0.1 The scheme option determines the scheme to use for parsing both the existing and new versions. The standard scheme is used by default, which is based on PEP 440 . Rather than setting the version explicitly, you can select the name of a segment used to increment the version: $ hatch version minor Old: 0.1 New: 0.2 You can chain multiple segment updates with a comma. For example, if you wanted to release a preview of your project's first major version, you could do: $ hatch version major,rc Old: 0.2 New: 1rc0","title":"Updating"},{"location":"version/#supported-segments","text":"Here are the supported segments and how they would influence an existing version of 1 : Segments New version major 2 minor 1.1 micro patch fix 1.0.1 a alpha 1a0 b beta 1b0 c rc pre preview 1rc0 r rev post 1.post0 dev 1.dev0","title":"Supported segments"},{"location":"cli/about/","text":"About \u00b6 Verbosity \u00b6 The amount of displayed output is controlled solely by the -v / --verbose (environment variable HATCH_VERBOSE ) and -q / --quiet (environment variable HATCH_QUIET ) root options . The levels are documented here . Project awareness \u00b6 No matter the mode , Hatch will always change to the project's root directory for entering or running commands in environments. Tab completion \u00b6 Completion is achieved by saving a script and then executing it as a part of your shell's startup sequence. Afterward, you'll need to start a new shell in order for the changes to take effect. Bash Z shell fish Save the script somewhere: _HATCH_COMPLETE=bash_source hatch > ~/.hatch-complete.bash Source the file in ~/.bashrc (or ~/.bash_profile if on macOS): . ~/.hatch-complete.bash Save the script somewhere: _HATCH_COMPLETE=zsh_source hatch > ~/.hatch-complete.zsh Source the file in ~/.zshrc : . ~/.hatch-complete.zsh Save the script in ~/.config/fish/completions : _HATCH_COMPLETE=fish_source hatch > ~/.config/fish/completions/hatch.fish","title":"About"},{"location":"cli/about/#about","text":"","title":"About"},{"location":"cli/about/#verbosity","text":"The amount of displayed output is controlled solely by the -v / --verbose (environment variable HATCH_VERBOSE ) and -q / --quiet (environment variable HATCH_QUIET ) root options . The levels are documented here .","title":"Verbosity"},{"location":"cli/about/#project-awareness","text":"No matter the mode , Hatch will always change to the project's root directory for entering or running commands in environments.","title":"Project awareness"},{"location":"cli/about/#tab-completion","text":"Completion is achieved by saving a script and then executing it as a part of your shell's startup sequence. Afterward, you'll need to start a new shell in order for the changes to take effect. Bash Z shell fish Save the script somewhere: _HATCH_COMPLETE=bash_source hatch > ~/.hatch-complete.bash Source the file in ~/.bashrc (or ~/.bash_profile if on macOS): . ~/.hatch-complete.bash Save the script somewhere: _HATCH_COMPLETE=zsh_source hatch > ~/.hatch-complete.zsh Source the file in ~/.zshrc : . ~/.hatch-complete.zsh Save the script in ~/.config/fish/completions : _HATCH_COMPLETE=fish_source hatch > ~/.config/fish/completions/hatch.fish","title":"Tab completion"},{"location":"cli/reference/","text":"hatch \u00b6 Usage: hatch [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --env , -e text The name of the environment to use [env var: HATCH_ENV ] default --project , -p text The name of the project to work on [env var: HATCH_PROJECT ] None --color / --no-color boolean Whether or not to display colored output (default is auto-detection) [env var: HATCH_COLOR ] None --verbose , -v integer range ( 0 and above) Increase verbosity (can be used additively) [env var: HATCH_VERBOSE ] 0 --quiet , -q integer range ( 0 and above) Decrease verbosity (can be used additively) [env var: HATCH_QUIET ] 0 --data-dir text The path to a custom directory used to persist data [env var: HATCH_DATA_DIR ] None --cache-dir text The path to a custom directory used to cache data [env var: HATCH_CACHE_DIR ] None --config text The path to a custom config file to use [env var: HATCH_CONFIG ] None --version boolean Show the version and exit. False --help boolean Show this message and exit. False hatch build \u00b6 Build a project. Usage: hatch build [OPTIONS] [LOCATION] Options: Name Type Description Default --target , -t text The target to build, overriding project defaults. This may be selected multiple times e.g. -t sdist -t wheel None --clean , -c boolean Whether or not each build target should first remove any of its existing artifacts False --ext boolean Whether or not to only execute build hooks for distributing binary Python packages, such as compiling extensions. Equivalent to --hooks-only -t wheel False --hooks-only boolean Whether or not to only execute build hooks False --help boolean Show this message and exit. False hatch config \u00b6 Manage the config file Usage: hatch config [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False hatch config explore \u00b6 Open the config location in your file manager. Usage: hatch config explore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config find \u00b6 Show the location of the config file. Usage: hatch config find [OPTIONS] Options: Name Type Description Default --copy , -c boolean Copy the path to the config file to the clipboard False --help boolean Show this message and exit. False hatch config restore \u00b6 Restore the config file to default settings. Usage: hatch config restore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config set \u00b6 Assign values to config file entries. If the value is omitted, you will be prompted, with the input hidden if it is sensitive. Usage: hatch config set [OPTIONS] KEY [VALUE] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config show \u00b6 Show the contents of the config file. Usage: hatch config show [OPTIONS] Options: Name Type Description Default --all , -a boolean No not scrub secret fields False --help boolean Show this message and exit. False hatch config update \u00b6 Update the config file with any new fields. Usage: hatch config update [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch dep \u00b6 Manage environment dependencies Usage: hatch dep [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False hatch dep hash \u00b6 Output a hash of the currently defined dependencies. Usage: hatch dep hash [OPTIONS] Options: Name Type Description Default --project-only , -p boolean Whether or not to exclude environment dependencies False --help boolean Show this message and exit. False hatch env \u00b6 Manage project environments Usage: hatch env [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False hatch env create \u00b6 Create environments. Usage: hatch env create [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env prune \u00b6 Remove all environments. Usage: hatch env prune [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env remove \u00b6 Remove environments. Usage: hatch env remove [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env show \u00b6 Show the available environments. Usage: hatch env show [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch new \u00b6 Create or initialize a project. Usage: hatch new [OPTIONS] [NAME] [LOCATION] Options: Name Type Description Default -i boolean Interactively choose details about the project False --cli boolean Give the project a command line interface False --init boolean Initialize an existing project False --help boolean Show this message and exit. False hatch publish \u00b6 Publish build artifacts. Usage: hatch publish [OPTIONS] [ARTIFACTS]... Options: Name Type Description Default --user , -u text The user with which to authenticate [env var: HATCH_PYPI_USER ] None --auth , -a text The credentials to use for authentication [env var: HATCH_PYPI_AUTH ] None --repo , -r text The repository with which to publish artifacts [env var: HATCH_PYPI_REPO ] None --no-prompt , -n boolean Do not prompt for missing required fields False --publisher , -p text The publisher plugin to use (default is pypi ) [env var: HATCH_PUBLISHER ] pypi --option , -o text Options to pass to the publisher plugin. This may be selected multiple times e.g. -o foo=bar -o baz=23 [env var: HATCH_PUBLISHER_OPTIONS ] None --help boolean Show this message and exit. False hatch run \u00b6 Run commands within a project's environment. Usage: hatch run [OPTIONS] ARGS... Options: Name Type Description Default --help boolean Show this message and exit. False hatch shell \u00b6 Enter a shell within a project's environment. Usage: hatch shell [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False hatch status \u00b6 Show information about the current environment. Usage: hatch status [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch version \u00b6 View or set a project's version. Usage: hatch version [OPTIONS] [DESIRED_VERSION] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"Reference"},{"location":"cli/reference/#hatch","text":"Usage: hatch [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --env , -e text The name of the environment to use [env var: HATCH_ENV ] default --project , -p text The name of the project to work on [env var: HATCH_PROJECT ] None --color / --no-color boolean Whether or not to display colored output (default is auto-detection) [env var: HATCH_COLOR ] None --verbose , -v integer range ( 0 and above) Increase verbosity (can be used additively) [env var: HATCH_VERBOSE ] 0 --quiet , -q integer range ( 0 and above) Decrease verbosity (can be used additively) [env var: HATCH_QUIET ] 0 --data-dir text The path to a custom directory used to persist data [env var: HATCH_DATA_DIR ] None --cache-dir text The path to a custom directory used to cache data [env var: HATCH_CACHE_DIR ] None --config text The path to a custom config file to use [env var: HATCH_CONFIG ] None --version boolean Show the version and exit. False --help boolean Show this message and exit. False","title":"hatch"},{"location":"cli/reference/#hatch-build","text":"Build a project. Usage: hatch build [OPTIONS] [LOCATION] Options: Name Type Description Default --target , -t text The target to build, overriding project defaults. This may be selected multiple times e.g. -t sdist -t wheel None --clean , -c boolean Whether or not each build target should first remove any of its existing artifacts False --ext boolean Whether or not to only execute build hooks for distributing binary Python packages, such as compiling extensions. Equivalent to --hooks-only -t wheel False --hooks-only boolean Whether or not to only execute build hooks False --help boolean Show this message and exit. False","title":"build"},{"location":"cli/reference/#hatch-config","text":"Manage the config file Usage: hatch config [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"config"},{"location":"cli/reference/#hatch-config-explore","text":"Open the config location in your file manager. Usage: hatch config explore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"explore"},{"location":"cli/reference/#hatch-config-find","text":"Show the location of the config file. Usage: hatch config find [OPTIONS] Options: Name Type Description Default --copy , -c boolean Copy the path to the config file to the clipboard False --help boolean Show this message and exit. False","title":"find"},{"location":"cli/reference/#hatch-config-restore","text":"Restore the config file to default settings. Usage: hatch config restore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"restore"},{"location":"cli/reference/#hatch-config-set","text":"Assign values to config file entries. If the value is omitted, you will be prompted, with the input hidden if it is sensitive. Usage: hatch config set [OPTIONS] KEY [VALUE] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"set"},{"location":"cli/reference/#hatch-config-show","text":"Show the contents of the config file. Usage: hatch config show [OPTIONS] Options: Name Type Description Default --all , -a boolean No not scrub secret fields False --help boolean Show this message and exit. False","title":"show"},{"location":"cli/reference/#hatch-config-update","text":"Update the config file with any new fields. Usage: hatch config update [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"update"},{"location":"cli/reference/#hatch-dep","text":"Manage environment dependencies Usage: hatch dep [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"dep"},{"location":"cli/reference/#hatch-dep-hash","text":"Output a hash of the currently defined dependencies. Usage: hatch dep hash [OPTIONS] Options: Name Type Description Default --project-only , -p boolean Whether or not to exclude environment dependencies False --help boolean Show this message and exit. False","title":"hash"},{"location":"cli/reference/#hatch-env","text":"Manage project environments Usage: hatch env [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"env"},{"location":"cli/reference/#hatch-env-create","text":"Create environments. Usage: hatch env create [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"create"},{"location":"cli/reference/#hatch-env-prune","text":"Remove all environments. Usage: hatch env prune [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"prune"},{"location":"cli/reference/#hatch-env-remove","text":"Remove environments. Usage: hatch env remove [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"remove"},{"location":"cli/reference/#hatch-env-show","text":"Show the available environments. Usage: hatch env show [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"show"},{"location":"cli/reference/#hatch-new","text":"Create or initialize a project. Usage: hatch new [OPTIONS] [NAME] [LOCATION] Options: Name Type Description Default -i boolean Interactively choose details about the project False --cli boolean Give the project a command line interface False --init boolean Initialize an existing project False --help boolean Show this message and exit. False","title":"new"},{"location":"cli/reference/#hatch-publish","text":"Publish build artifacts. Usage: hatch publish [OPTIONS] [ARTIFACTS]... Options: Name Type Description Default --user , -u text The user with which to authenticate [env var: HATCH_PYPI_USER ] None --auth , -a text The credentials to use for authentication [env var: HATCH_PYPI_AUTH ] None --repo , -r text The repository with which to publish artifacts [env var: HATCH_PYPI_REPO ] None --no-prompt , -n boolean Do not prompt for missing required fields False --publisher , -p text The publisher plugin to use (default is pypi ) [env var: HATCH_PUBLISHER ] pypi --option , -o text Options to pass to the publisher plugin. This may be selected multiple times e.g. -o foo=bar -o baz=23 [env var: HATCH_PUBLISHER_OPTIONS ] None --help boolean Show this message and exit. False","title":"publish"},{"location":"cli/reference/#hatch-run","text":"Run commands within a project's environment. Usage: hatch run [OPTIONS] ARGS... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"run"},{"location":"cli/reference/#hatch-shell","text":"Enter a shell within a project's environment. Usage: hatch shell [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"shell"},{"location":"cli/reference/#hatch-status","text":"Show information about the current environment. Usage: hatch status [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"status"},{"location":"cli/reference/#hatch-version","text":"View or set a project's version. Usage: hatch version [OPTIONS] [DESIRED_VERSION] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"version"},{"location":"config/build/","text":"Build configuration \u00b6 All build configuration is defined in the tool.hatch.build table. Build targets are defined as sections within tool.hatch.build.targets : pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>] [build.targets.<TARGET_NAME>] For each build target you may override any of the defaults set in the top-level tool.hatch.build table. Build system \u00b6 To be compatible with the broader Python packaging ecosystem , you must define the build system as follows: pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" The version of hatchling defined here will be used to build all targets. Hatchling is a PEP 517 / PEP 660 compatible build system and is a dependency of Hatch itself. File selection \u00b6 VCS \u00b6 By default, Hatch will respect any .gitignore file located at your project's root. Set ignore-vcs to true to disable this behavior: pyproject.toml hatch.toml [tool.hatch.build] ignore-vcs = true [build] ignore-vcs = true Patterns \u00b6 You can set the include and exclude options to select exactly which files will be shipped in each build, with exclude taking precedence. The options may be defined as either an array of strings or a comma-separated string, with every entry representing a Git-style glob pattern . For example, the following configuration: pyproject.toml hatch.toml [tool.hatch.build] include = [ \"pkg/*.py\" , \"/tests\" , ] exclude = \"*.json,pkg/_compat.py\" [build] include = [ \"pkg/*.py\" , \"/tests\" , ] exclude = \"*.json,pkg/_compat.py\" will exclude every file with a .json extension, and will include everything under a tests directory located at the root and every file with a .py extension that is directly under a pkg directory located at the root except for _compat.py . Packages \u00b6 The packages option can be used to include specific Python packages. This option is semantically equivalent to include except that every entry is a simple relative path and the shipped path will be collapsed to only include the final component. So for example, if you want to ship a package foo that is stored in a directory src you would do: pyproject.toml hatch.toml [tool.hatch.build] packages = \"src/foo\" [build] packages = \"src/foo\" Artifacts \u00b6 If you want to include files that are ignored by your VCS , such as those that might be created by build hooks , you can use the artifacts option. This option is semantically equivalent to include . pyproject.toml hatch.toml [tool.hatch.build] artifacts = [ \"*.so\" , \"*.dll\" , ] [build] artifacts = [ \"*.so\" , \"*.dll\" , ] Default file selection \u00b6 If no file selection options are provided, then what gets included is determined by each build target . Reproducible builds \u00b6 By default, build targets will build in a reproducible manner provided that they support that behavior. To disable this, set reproducible to false : pyproject.toml hatch.toml [tool.hatch.build] reproducible = false [build] reproducible = false Output directory \u00b6 When the output directory is not provided to the build command, the dist directory will be used by default. You can change the default to a different directory using a relative or absolute path like so: pyproject.toml hatch.toml [tool.hatch.build] directory = \"<PATH>\" [build] directory = \"<PATH>\" Dev mode \u00b6 In most cases, dev mode environment installations or editable installs in general will work as expected. However, for some project layouts you need to explicitly define which directories to add to Python's search path, such as for namespace packages . You can do this with the dev-mode-dirs option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.build] dev-mode-dirs = \".\" [build] dev-mode-dirs = \".\" Build targets \u00b6 A build target can be provided by any builder plugin . There are three built-in build targets: wheel , sdist , and custom . Dependencies \u00b6 You can specify additional dependencies that will be installed in each build environment, such as for third party builders: pyproject.toml hatch.toml [tool.hatch.build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ] [build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ] Versions \u00b6 If a build target supports multiple build strategies or if there are major changes over time, you can specify exactly which versions you want to build using the versions option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ] [build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ] Build hooks \u00b6 A build hook defines code that will be executed at various stages of the build process and can be provided by any build hook plugin . There is one built-in build hook: custom . Build hooks can be applied either globally: pyproject.toml hatch.toml [tool.hatch.build.hooks.<HOOK_NAME>] [build.hooks.<HOOK_NAME>] or to specific build targets: pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>] [build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>] Dependencies \u00b6 You can specify additional dependencies that will be installed in each build environment, such as for third party build hooks: pyproject.toml hatch.toml [tool.hatch.build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ] [build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ] Order of execution \u00b6 For each build target, build hooks execute in the order in which they are defined, starting with target-specific hooks. As an example, for the following configuration: pyproject.toml hatch.toml [tool.hatch.build.hooks.hook3] [tool.hatch.build.hooks.hook1] [tool.hatch.build.targets.foo.hooks.hook2] [build.hooks.hook3] [build.hooks.hook1] [build.targets.foo.hooks.hook2] When target foo is built, build hook hook2 will be executed first, followed by hook3 , and then finally hook1 .","title":"Build"},{"location":"config/build/#build-configuration","text":"All build configuration is defined in the tool.hatch.build table. Build targets are defined as sections within tool.hatch.build.targets : pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>] [build.targets.<TARGET_NAME>] For each build target you may override any of the defaults set in the top-level tool.hatch.build table.","title":"Build configuration"},{"location":"config/build/#build-system","text":"To be compatible with the broader Python packaging ecosystem , you must define the build system as follows: pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" The version of hatchling defined here will be used to build all targets. Hatchling is a PEP 517 / PEP 660 compatible build system and is a dependency of Hatch itself.","title":"Build system"},{"location":"config/build/#file-selection","text":"","title":"File selection"},{"location":"config/build/#vcs","text":"By default, Hatch will respect any .gitignore file located at your project's root. Set ignore-vcs to true to disable this behavior: pyproject.toml hatch.toml [tool.hatch.build] ignore-vcs = true [build] ignore-vcs = true","title":"VCS"},{"location":"config/build/#patterns","text":"You can set the include and exclude options to select exactly which files will be shipped in each build, with exclude taking precedence. The options may be defined as either an array of strings or a comma-separated string, with every entry representing a Git-style glob pattern . For example, the following configuration: pyproject.toml hatch.toml [tool.hatch.build] include = [ \"pkg/*.py\" , \"/tests\" , ] exclude = \"*.json,pkg/_compat.py\" [build] include = [ \"pkg/*.py\" , \"/tests\" , ] exclude = \"*.json,pkg/_compat.py\" will exclude every file with a .json extension, and will include everything under a tests directory located at the root and every file with a .py extension that is directly under a pkg directory located at the root except for _compat.py .","title":"Patterns"},{"location":"config/build/#packages","text":"The packages option can be used to include specific Python packages. This option is semantically equivalent to include except that every entry is a simple relative path and the shipped path will be collapsed to only include the final component. So for example, if you want to ship a package foo that is stored in a directory src you would do: pyproject.toml hatch.toml [tool.hatch.build] packages = \"src/foo\" [build] packages = \"src/foo\"","title":"Packages"},{"location":"config/build/#artifacts","text":"If you want to include files that are ignored by your VCS , such as those that might be created by build hooks , you can use the artifacts option. This option is semantically equivalent to include . pyproject.toml hatch.toml [tool.hatch.build] artifacts = [ \"*.so\" , \"*.dll\" , ] [build] artifacts = [ \"*.so\" , \"*.dll\" , ]","title":"Artifacts"},{"location":"config/build/#default-file-selection","text":"If no file selection options are provided, then what gets included is determined by each build target .","title":"Default file selection"},{"location":"config/build/#reproducible-builds","text":"By default, build targets will build in a reproducible manner provided that they support that behavior. To disable this, set reproducible to false : pyproject.toml hatch.toml [tool.hatch.build] reproducible = false [build] reproducible = false","title":"Reproducible builds"},{"location":"config/build/#output-directory","text":"When the output directory is not provided to the build command, the dist directory will be used by default. You can change the default to a different directory using a relative or absolute path like so: pyproject.toml hatch.toml [tool.hatch.build] directory = \"<PATH>\" [build] directory = \"<PATH>\"","title":"Output directory"},{"location":"config/build/#dev-mode","text":"In most cases, dev mode environment installations or editable installs in general will work as expected. However, for some project layouts you need to explicitly define which directories to add to Python's search path, such as for namespace packages . You can do this with the dev-mode-dirs option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.build] dev-mode-dirs = \".\" [build] dev-mode-dirs = \".\"","title":"Dev mode"},{"location":"config/build/#build-targets","text":"A build target can be provided by any builder plugin . There are three built-in build targets: wheel , sdist , and custom .","title":"Build targets"},{"location":"config/build/#dependencies","text":"You can specify additional dependencies that will be installed in each build environment, such as for third party builders: pyproject.toml hatch.toml [tool.hatch.build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ] [build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ]","title":"Dependencies"},{"location":"config/build/#versions","text":"If a build target supports multiple build strategies or if there are major changes over time, you can specify exactly which versions you want to build using the versions option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ] [build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ]","title":"Versions"},{"location":"config/build/#build-hooks","text":"A build hook defines code that will be executed at various stages of the build process and can be provided by any build hook plugin . There is one built-in build hook: custom . Build hooks can be applied either globally: pyproject.toml hatch.toml [tool.hatch.build.hooks.<HOOK_NAME>] [build.hooks.<HOOK_NAME>] or to specific build targets: pyproject.toml hatch.toml [tool.hatch.build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>] [build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>]","title":"Build hooks"},{"location":"config/build/#dependencies_1","text":"You can specify additional dependencies that will be installed in each build environment, such as for third party build hooks: pyproject.toml hatch.toml [tool.hatch.build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ] [build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ]","title":"Dependencies"},{"location":"config/build/#order-of-execution","text":"For each build target, build hooks execute in the order in which they are defined, starting with target-specific hooks. As an example, for the following configuration: pyproject.toml hatch.toml [tool.hatch.build.hooks.hook3] [tool.hatch.build.hooks.hook1] [tool.hatch.build.targets.foo.hooks.hook2] [build.hooks.hook3] [build.hooks.hook1] [build.targets.foo.hooks.hook2] When target foo is built, build hook hook2 will be executed first, followed by hook3 , and then finally hook1 .","title":"Order of execution"},{"location":"config/dependency/","text":"Dependency configuration \u00b6 :root { font-variant-ligatures: none; } Project dependencies are defined with PEP 508 strings using optional PEP 440 version specifiers . Version specifiers \u00b6 A version specifier consists of a series of version clauses, separated by commas. For example: pyproject.toml [project] ... dependencies = [ \"cryptography\" , \"click>=7, <9, != 8.0.0\" , \"python-dateutil==2.8.*\" , \"numpy~=1.21.4\" , ] The comma is equivalent to a logical AND operator: a candidate version must match all given version clauses in order to match the specifier as a whole. Operators \u00b6 Operators Function ~= Compatible release == Version matching != Version exclusion <= , >= Inclusive ordered comparison < , > Exclusive ordered comparison === Arbitrary equality Version matching \u00b6 A version matching clause includes the version matching operator == and a version identifier. By default, the version matching operator is based on a strict equality comparison: the specified version must be exactly the same as the requested version. Clause Allowed versions ==1 1.0.0 ==1.2 1.2.0 Prefix matching may be requested instead of strict comparison, by appending a trailing .* to the version identifier in the version matching clause. This means that additional trailing segments will be ignored when determining whether or not a version identifier matches the clause. Clause Allowed versions ==1.* >=1.0.0, <2.0.0 ==1.2.* >=1.2.0, <1.3.0 Compatible release \u00b6 A compatible release clause consists of the compatible release operator ~= and a version identifier. It matches any candidate version that is expected to be compatible with the specified version. For a given release identifier V.N , the compatible release clause is approximately equivalent to the following pair of comparison clauses: >= V.N, == V.* This operator cannot be used with a single segment version number such as ~=1 . Clause Allowed versions ~=1.2 >=1.2.0, <2.0.0 ~=1.2.3 >=1.2.3, <1.3.0 Version exclusion \u00b6 A version exclusion clause includes the version exclusion operator != and a version identifier. The allowed version identifiers and comparison semantics are the same as those of the Version matching operator, except that the sense of any match is inverted. Ordered comparison \u00b6 Inclusive comparisons allow for the version identifier part of clauses whereas exclusive comparisons do not. For example, >=1.2 allows for version 1.2.0 while >1.2 does not. Unlike the inclusive ordered comparisons <= and >= , the exclusive ordered comparisons < and > specifically exclude pre-releases, post-releases, and local versions of the specified version. Arbitrary equality \u00b6 Though heavily discouraged, arbitrary equality comparisons allow for simple string matching without any version semantics, for example ===foobar . Environment markers \u00b6 Environment markers allow for dependencies to only be installed when certain conditions are met. For example, if you need to install the latest version of cryptography that is available for a given Python major version you could define the following: cryptography==3.3.2; python_version < \"3\" cryptography>=35.0; python_version > \"3\" Alternatively, if you only need it on Python 3 when running on Windows you could do: cryptography; python_version ~= \"3.0\" and platform_system == \"Windows\" The available environment markers are as follows. Marker Python equivalent Examples os_name import os os.name posix java sys_platform import sys sys.platform linux win32 darwin platform_machine import platform platform.machine() x86_64 platform_python_implementation import platform platform.python_implementation() CPython Jython platform_release import platform platform.release() 1.8.0_51 3.14.1-x86_64-linode39 platform_system import platform platform.system() Linux Windows Darwin platform_version import platform platform.version() 10.0.19041 #1 SMP Fri Apr 2 22:23:49 UTC 2021 python_version import platform '.'.join(platform.python_version_tuple()[:2]) 2.7 3.10 python_full_version import platform platform.python_version() 2.7.18 3.11.0b1 implementation_name import sys sys.implementation.name cpython implementation_version See here 2.7.18 3.11.0b1 Features \u00b6 You can select groups of optional dependencies to install using the extras syntax. For example, if a dependency named foo defined the following: pyproject.toml [project.optional-dependencies] crypto = [ \"PyJWT\" , \"cryptography\" , ] fastjson = [ \"orjson\" , ] cli = [ \"prompt-toolkit\" , \"colorama; platform_system == 'Windows'\" , ] You can select the cli and crypto features like so: foo[cli,crypto]==1.* Note that the features come immediately after the package name, before any version specifiers . Direct references \u00b6 Instead of using normal version specifiers and fetching packages from an index like PyPI , you can define exact sources using direct references with an explicit URI . Direct references are not meant to be used for dependencies of a published project but rather are used for defining dependencies for an environment . Version control systems \u00b6 Various version control systems (VCS) are supported as long as the associated executable is available along your PATH . VCS direct references are defined using one of the following formats: <SCHEME>://<PATH> <SCHEME>://<PATH>@<REVISION> You may also append a #subdirectory=<PATH> component for specifying the relative path to the Python package when it is not located at the root e.g. #subdirectory=lib/foo . For more information, refer to this . Supported VCS \u00b6 Git Mercurial Subversion Bazaar Executable Schemes Revisions Example git git+file git+https git+ssh git+http git+git git Commit hash Tag name Branch name git+https://github.com/org/proj.git@v1 Executable Schemes Revisions Example hg hg+file hg+https hg+ssh hg+http hg+static-http Revision hash Revision number Tag name Branch name hg+file:///path/to/proj@v1 Executable Schemes Revisions Example svn svn+https svn+ssh svn+http svn+svn svn Revision number svn+file:///path/to/proj Executable Schemes Revisions Example bzr bzr+https bzr+ssh bzr+sftp bzr+lp bzr+http bzr+ftp Revision number Tag name bzr+lp:proj@v1 Local \u00b6 You can install local packages with the file scheme in the following format: file://<HOST>/<PATH> The <HOST> is only used on Windows systems, where it can refer to a network share. If omitted it is assumed to be localhost and the third slash must still be present. The <PATH> can refer to a source archive, a wheel, or a directory containing a Python package. Type Unix Windows Source archive file:///path/to/pkg.tar.gz file:///c:/path/to/pkg.tar.gz Wheel file:///path/to/pkg.whl file:///c:/path/to/pkg.whl Directory file:///path/to/pkg file:///c:/path/to/pkg You may also specify paths relative to your project's root directory on all platforms by omitting the leading slashes and beginning the path with a dot: file:./pkg_inside_project file:../pkg_alongside_project Remote \u00b6 You can install source archives and wheels by simply referring to a URL: https://github.com/psf/black/archive/refs/tags/21.10b0.zip https://download.pytorch.org/whl/cu102/torch-1.10.0%2Bcu102-cp39-cp39-linux_x86_64.whl An expected hash value may be specified by appending a #<HASH_ALGORITHM>=<EXPECTED_HASH> component: https://github.com/psf/requests/archive/refs/tags/v2.26.0.zip#sha256=eb729a757f01c10546ebd179ae2aec852dd0d7f8ada2328ccf4558909d859985 If the hash differs from the expected hash, the installation will fail. It is recommended that only hashes which are unconditionally provided by the latest version of the standard library's hashlib module be used for hashes. As of Python 3.10, that list consists of: md5 sha1 sha224 sha256 sha384 sha512 blake2b blake2s","title":"Dependencies"},{"location":"config/dependency/#dependency-configuration","text":":root { font-variant-ligatures: none; } Project dependencies are defined with PEP 508 strings using optional PEP 440 version specifiers .","title":"Dependency configuration"},{"location":"config/dependency/#version-specifiers","text":"A version specifier consists of a series of version clauses, separated by commas. For example: pyproject.toml [project] ... dependencies = [ \"cryptography\" , \"click>=7, <9, != 8.0.0\" , \"python-dateutil==2.8.*\" , \"numpy~=1.21.4\" , ] The comma is equivalent to a logical AND operator: a candidate version must match all given version clauses in order to match the specifier as a whole.","title":"Version specifiers"},{"location":"config/dependency/#operators","text":"Operators Function ~= Compatible release == Version matching != Version exclusion <= , >= Inclusive ordered comparison < , > Exclusive ordered comparison === Arbitrary equality","title":"Operators"},{"location":"config/dependency/#version-matching","text":"A version matching clause includes the version matching operator == and a version identifier. By default, the version matching operator is based on a strict equality comparison: the specified version must be exactly the same as the requested version. Clause Allowed versions ==1 1.0.0 ==1.2 1.2.0 Prefix matching may be requested instead of strict comparison, by appending a trailing .* to the version identifier in the version matching clause. This means that additional trailing segments will be ignored when determining whether or not a version identifier matches the clause. Clause Allowed versions ==1.* >=1.0.0, <2.0.0 ==1.2.* >=1.2.0, <1.3.0","title":"Version matching"},{"location":"config/dependency/#compatible-release","text":"A compatible release clause consists of the compatible release operator ~= and a version identifier. It matches any candidate version that is expected to be compatible with the specified version. For a given release identifier V.N , the compatible release clause is approximately equivalent to the following pair of comparison clauses: >= V.N, == V.* This operator cannot be used with a single segment version number such as ~=1 . Clause Allowed versions ~=1.2 >=1.2.0, <2.0.0 ~=1.2.3 >=1.2.3, <1.3.0","title":"Compatible release"},{"location":"config/dependency/#version-exclusion","text":"A version exclusion clause includes the version exclusion operator != and a version identifier. The allowed version identifiers and comparison semantics are the same as those of the Version matching operator, except that the sense of any match is inverted.","title":"Version exclusion"},{"location":"config/dependency/#ordered-comparison","text":"Inclusive comparisons allow for the version identifier part of clauses whereas exclusive comparisons do not. For example, >=1.2 allows for version 1.2.0 while >1.2 does not. Unlike the inclusive ordered comparisons <= and >= , the exclusive ordered comparisons < and > specifically exclude pre-releases, post-releases, and local versions of the specified version.","title":"Ordered comparison"},{"location":"config/dependency/#arbitrary-equality","text":"Though heavily discouraged, arbitrary equality comparisons allow for simple string matching without any version semantics, for example ===foobar .","title":"Arbitrary equality"},{"location":"config/dependency/#environment-markers","text":"Environment markers allow for dependencies to only be installed when certain conditions are met. For example, if you need to install the latest version of cryptography that is available for a given Python major version you could define the following: cryptography==3.3.2; python_version < \"3\" cryptography>=35.0; python_version > \"3\" Alternatively, if you only need it on Python 3 when running on Windows you could do: cryptography; python_version ~= \"3.0\" and platform_system == \"Windows\" The available environment markers are as follows. Marker Python equivalent Examples os_name import os os.name posix java sys_platform import sys sys.platform linux win32 darwin platform_machine import platform platform.machine() x86_64 platform_python_implementation import platform platform.python_implementation() CPython Jython platform_release import platform platform.release() 1.8.0_51 3.14.1-x86_64-linode39 platform_system import platform platform.system() Linux Windows Darwin platform_version import platform platform.version() 10.0.19041 #1 SMP Fri Apr 2 22:23:49 UTC 2021 python_version import platform '.'.join(platform.python_version_tuple()[:2]) 2.7 3.10 python_full_version import platform platform.python_version() 2.7.18 3.11.0b1 implementation_name import sys sys.implementation.name cpython implementation_version See here 2.7.18 3.11.0b1","title":"Environment markers"},{"location":"config/dependency/#features","text":"You can select groups of optional dependencies to install using the extras syntax. For example, if a dependency named foo defined the following: pyproject.toml [project.optional-dependencies] crypto = [ \"PyJWT\" , \"cryptography\" , ] fastjson = [ \"orjson\" , ] cli = [ \"prompt-toolkit\" , \"colorama; platform_system == 'Windows'\" , ] You can select the cli and crypto features like so: foo[cli,crypto]==1.* Note that the features come immediately after the package name, before any version specifiers .","title":"Features"},{"location":"config/dependency/#direct-references","text":"Instead of using normal version specifiers and fetching packages from an index like PyPI , you can define exact sources using direct references with an explicit URI . Direct references are not meant to be used for dependencies of a published project but rather are used for defining dependencies for an environment .","title":"Direct references"},{"location":"config/dependency/#version-control-systems","text":"Various version control systems (VCS) are supported as long as the associated executable is available along your PATH . VCS direct references are defined using one of the following formats: <SCHEME>://<PATH> <SCHEME>://<PATH>@<REVISION> You may also append a #subdirectory=<PATH> component for specifying the relative path to the Python package when it is not located at the root e.g. #subdirectory=lib/foo . For more information, refer to this .","title":"Version control systems"},{"location":"config/dependency/#supported-vcs","text":"Git Mercurial Subversion Bazaar Executable Schemes Revisions Example git git+file git+https git+ssh git+http git+git git Commit hash Tag name Branch name git+https://github.com/org/proj.git@v1 Executable Schemes Revisions Example hg hg+file hg+https hg+ssh hg+http hg+static-http Revision hash Revision number Tag name Branch name hg+file:///path/to/proj@v1 Executable Schemes Revisions Example svn svn+https svn+ssh svn+http svn+svn svn Revision number svn+file:///path/to/proj Executable Schemes Revisions Example bzr bzr+https bzr+ssh bzr+sftp bzr+lp bzr+http bzr+ftp Revision number Tag name bzr+lp:proj@v1","title":"Supported VCS"},{"location":"config/dependency/#local","text":"You can install local packages with the file scheme in the following format: file://<HOST>/<PATH> The <HOST> is only used on Windows systems, where it can refer to a network share. If omitted it is assumed to be localhost and the third slash must still be present. The <PATH> can refer to a source archive, a wheel, or a directory containing a Python package. Type Unix Windows Source archive file:///path/to/pkg.tar.gz file:///c:/path/to/pkg.tar.gz Wheel file:///path/to/pkg.whl file:///c:/path/to/pkg.whl Directory file:///path/to/pkg file:///c:/path/to/pkg You may also specify paths relative to your project's root directory on all platforms by omitting the leading slashes and beginning the path with a dot: file:./pkg_inside_project file:../pkg_alongside_project","title":"Local"},{"location":"config/dependency/#remote","text":"You can install source archives and wheels by simply referring to a URL: https://github.com/psf/black/archive/refs/tags/21.10b0.zip https://download.pytorch.org/whl/cu102/torch-1.10.0%2Bcu102-cp39-cp39-linux_x86_64.whl An expected hash value may be specified by appending a #<HASH_ALGORITHM>=<EXPECTED_HASH> component: https://github.com/psf/requests/archive/refs/tags/v2.26.0.zip#sha256=eb729a757f01c10546ebd179ae2aec852dd0d7f8ada2328ccf4558909d859985 If the hash differs from the expected hash, the installation will fail. It is recommended that only hashes which are unconditionally provided by the latest version of the standard library's hashlib module be used for hashes. As of Python 3.10, that list consists of: md5 sha1 sha224 sha256 sha384 sha512 blake2b blake2s","title":"Remote"},{"location":"config/environment/","text":"Environment configuration \u00b6 All environments are defined as sections within the tool.hatch.envs table. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] [envs.<ENV_NAME>] Unless an environment is explicitly selected on the command line, the default environment will be used. The type of this environment defaults to virtual . Inheritance \u00b6 All environments inherit from the environment defined by its template option, which defaults to default . So for the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.foo] type = \"baz\" skip-install = true [tool.hatch.envs.bar] template = \"foo\" skip-install = false [envs.foo] type = \"baz\" skip-install = true [envs.bar] template = \"foo\" skip-install = false the environment bar will be of type baz with skip-install set to false . Note Environments do not inherit matrices . Dependencies \u00b6 You can install dependencies in addition to the ones defined by your project's metadata . pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] Installation \u00b6 Features \u00b6 If your project defines optional dependencies , you can select which groups to install using the features option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.envs.nightly] features = [ \"server\" , \"grpc\" , ] [envs.nightly] features = [ \"server\" , \"grpc\" , ] Dev mode \u00b6 By default, environments will always reflect the current state of your project on disk. Set dev-mode to false to disable this behavior: pyproject.toml hatch.toml [tool.hatch.envs.static] dev-mode = false [envs.static] dev-mode = false Skip install \u00b6 By default, environments will install your project during creation. To ignore this step, set skip-install to true : pyproject.toml hatch.toml [tool.hatch.envs.lint] skip-install = true [envs.lint] skip-install = true Environment variables \u00b6 You can define environment variables with the env-vars option: pyproject.toml hatch.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\" [envs.docs] dependencies = [ \"mkdocs\" ] [envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\" Scripts \u00b6 You can define named scripts that may be executed or referenced at the beginning of other scripts. For example, in the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [tool.hatch.envs.test.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [envs.test.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" the run script would be expanded to: pytest --cov-config=pyproject.toml --cov=pkg --cov=tests --no-cov Scripts can also be defined as an array of strings. pyproject.toml hatch.toml [tool.hatch.envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [tool.hatch.envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] [envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] Tip Scripts inherit from parent environments just like options. Commands \u00b6 All commands are able to use any defined scripts . Pre-install \u00b6 You can run commands immediately before environments install your project. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ] [envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ] Post-install \u00b6 You can run commands immediately after environments install your project. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] post-install-commands = [ \"...\" , ] [envs.<ENV_NAME>] post-install-commands = [ \"...\" , ] Python version \u00b6 The python option selects which version of Python to use: pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] python = \"3.10\" [envs.<ENV_NAME>] python = \"3.10\" All environment types should respect this option. Supported platforms \u00b6 The platforms option indicates the operating systems with which the environment is compatible: pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] platforms = [ \"linux\" , \"windows\" , \"macos\" ] [envs.<ENV_NAME>] platforms = [ \"linux\" , \"windows\" , \"macos\" ] If unspecified, the environment is assumed to be compatible with all platforms. Type \u00b6 An environment's type determines which environment plugin will be used for management. The only built-in environment type is virtual , which uses virtual Python environments. Matrix \u00b6 Environments can define a series of matrices with the matrix option: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"pytest\" ] [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[tool.hatch.envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] [envs.test] dependencies = [ \"pytest\" ] [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] Doing so will result in the product of each variable combination being its own environment. Naming \u00b6 The name of the generated environments will be the variable values of each combination separated by hyphens, altogether prefixed by <ENV_NAME>. . For example, the following configuration: pyproject.toml hatch.toml [[tool.hatch.envs.test.matrix]] version = [ \"42\" ] features = [ \"foo\" , \"bar\" ] [[envs.test.matrix]] version = [ \"42\" ] features = [ \"foo\" , \"bar\" ] would indicate the following unique environments: test.42-foo test.42-bar The two exceptions to this format are described below. Python variables \u00b6 If the variables py or python are specified, then they will rank first in the product result and will be prefixed by py if the value is not. For example, the following configuration: pyproject.toml hatch.toml [[tool.hatch.envs.test.matrix]] version = [ \"42\" ] python = [ \"39\" , \"pypy3\" ] [[envs.test.matrix]] version = [ \"42\" ] python = [ \"39\" , \"pypy3\" ] would generate the following environments: test.py39-42 test.pypy3-42 Note The value of this variable sets the Python version . Default environment \u00b6 If the default environment defines matrices, then the generated names will not be prefixed by the environment name. This can be useful for projects that only need a single series of matrices without any standalone environments. Selection \u00b6 Rather than selecting a single generated environment, you can select the root environment to target all of them. For example, if you have the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , ] [tool.hatch.envs.test.scripts] cov = 'pytest --cov-report=term-missing --cov=pkg --cov=tests' [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , ] [envs.test.scripts] cov = 'pytest --cov-report=term-missing --cov=pkg --cov=tests' [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] you could then run your tests consecutively in all 4 environments with: hatch run test:cov Variable options \u00b6 The variables used to generate each environment can be used to modify options within using the vars option in the root environment. The syntax uses dotted keys : vars . < VARIABLE > . < OPTION > = < VALUE > The type of the selected option determines the types of values. Mapping types \u00b6 Mapping types like environment variables can have keys set using a string, or an array of strings or inline tables. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . env-vars = \"KEY=VALUE\" vars . bar . env-vars = [ \"KEY1=VALUE1\" , { key = \"KEY2\" , value = \"VALUE2\" }, ] [envs.test] vars . foo . env-vars = \"KEY=VALUE\" vars . bar . env-vars = [ \"KEY1=VALUE1\" , { key = \"KEY2\" , value = \"VALUE2\" }, ] If the value is missing (no = for strings, no value key for inline tables), then the value will be set to the value of the variable used to generate the environment. Array types \u00b6 Array types like dependencies or commands can be appended to using an array of strings or inline tables. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . dependencies = [ \"httpx\" , { value = \"cryptography\" }, ] [envs.test] vars . foo . dependencies = [ \"httpx\" , { value = \"cryptography\" }, ] String types \u00b6 String types like the Python version or environment type can be set using a string or an inline table. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . python = \"310\" vars . bar . python = { value = \"38\" } [envs.test] vars . foo . python = \"310\" vars . bar . python = { value = \"38\" } Overwriting \u00b6 Rather than supplementing the values within mapping types or array types , you can overwrite the option as a whole by prefixing the name with set- : pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . set-platforms = [ \"macos\" , \"linux\" ] [envs.test] vars . foo . set-platforms = [ \"macos\" , \"linux\" ] Conditions \u00b6 You may specify certain extra keys for any inline table that will determine whether or not to apply that entry. Allowed values \u00b6 The if key represents the allowed values for that variable. If the value of the variable used to generate the environment is not listed, then that entry will not be applied: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . version . python = { value = \"pypy\" , if = [ \"3.14\" ] } vars . version . env-vars = [ { key = \"KEY1\" , value = \"VALUE1\" , if = [ \"42\" ] }, { key = \"KEY2\" , value = \"VALUE2\" , if = [ \"3.14\" ] }, ] [[tool.hatch.envs.test.matrix]] version = [ \"42\" , \"3.14\" ] [envs.test] vars . version . python = { value = \"pypy\" , if = [ \"3.14\" ] } vars . version . env-vars = [ { key = \"KEY1\" , value = \"VALUE1\" , if = [ \"42\" ] }, { key = \"KEY2\" , value = \"VALUE2\" , if = [ \"3.14\" ] }, ] [[envs.test.matrix]] version = [ \"42\" , \"3.14\" ]","title":"Environments"},{"location":"config/environment/#environment-configuration","text":"All environments are defined as sections within the tool.hatch.envs table. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] [envs.<ENV_NAME>] Unless an environment is explicitly selected on the command line, the default environment will be used. The type of this environment defaults to virtual .","title":"Environment configuration"},{"location":"config/environment/#inheritance","text":"All environments inherit from the environment defined by its template option, which defaults to default . So for the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.foo] type = \"baz\" skip-install = true [tool.hatch.envs.bar] template = \"foo\" skip-install = false [envs.foo] type = \"baz\" skip-install = true [envs.bar] template = \"foo\" skip-install = false the environment bar will be of type baz with skip-install set to false . Note Environments do not inherit matrices .","title":"Inheritance"},{"location":"config/environment/#dependencies","text":"You can install dependencies in addition to the ones defined by your project's metadata . pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ]","title":"Dependencies"},{"location":"config/environment/#installation","text":"","title":"Installation"},{"location":"config/environment/#features","text":"If your project defines optional dependencies , you can select which groups to install using the features option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml hatch.toml [tool.hatch.envs.nightly] features = [ \"server\" , \"grpc\" , ] [envs.nightly] features = [ \"server\" , \"grpc\" , ]","title":"Features"},{"location":"config/environment/#dev-mode","text":"By default, environments will always reflect the current state of your project on disk. Set dev-mode to false to disable this behavior: pyproject.toml hatch.toml [tool.hatch.envs.static] dev-mode = false [envs.static] dev-mode = false","title":"Dev mode"},{"location":"config/environment/#skip-install","text":"By default, environments will install your project during creation. To ignore this step, set skip-install to true : pyproject.toml hatch.toml [tool.hatch.envs.lint] skip-install = true [envs.lint] skip-install = true","title":"Skip install"},{"location":"config/environment/#environment-variables","text":"You can define environment variables with the env-vars option: pyproject.toml hatch.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\" [envs.docs] dependencies = [ \"mkdocs\" ] [envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\"","title":"Environment variables"},{"location":"config/environment/#scripts","text":"You can define named scripts that may be executed or referenced at the beginning of other scripts. For example, in the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [tool.hatch.envs.test.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [envs.test.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" the run script would be expanded to: pytest --cov-config=pyproject.toml --cov=pkg --cov=tests --no-cov Scripts can also be defined as an array of strings. pyproject.toml hatch.toml [tool.hatch.envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [tool.hatch.envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] [envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] Tip Scripts inherit from parent environments just like options.","title":"Scripts"},{"location":"config/environment/#commands","text":"All commands are able to use any defined scripts .","title":"Commands"},{"location":"config/environment/#pre-install","text":"You can run commands immediately before environments install your project. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ] [envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ]","title":"Pre-install"},{"location":"config/environment/#post-install","text":"You can run commands immediately after environments install your project. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] post-install-commands = [ \"...\" , ] [envs.<ENV_NAME>] post-install-commands = [ \"...\" , ]","title":"Post-install"},{"location":"config/environment/#python-version","text":"The python option selects which version of Python to use: pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] python = \"3.10\" [envs.<ENV_NAME>] python = \"3.10\" All environment types should respect this option.","title":"Python version"},{"location":"config/environment/#supported-platforms","text":"The platforms option indicates the operating systems with which the environment is compatible: pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] platforms = [ \"linux\" , \"windows\" , \"macos\" ] [envs.<ENV_NAME>] platforms = [ \"linux\" , \"windows\" , \"macos\" ] If unspecified, the environment is assumed to be compatible with all platforms.","title":"Supported platforms"},{"location":"config/environment/#type","text":"An environment's type determines which environment plugin will be used for management. The only built-in environment type is virtual , which uses virtual Python environments.","title":"Type"},{"location":"config/environment/#matrix","text":"Environments can define a series of matrices with the matrix option: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"pytest\" ] [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[tool.hatch.envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] [envs.test] dependencies = [ \"pytest\" ] [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [[envs.test.matrix]] python = [ \"38\" , \"39\" ] version = [ \"9000\" ] features = [ \"foo\" , \"bar\" ] Doing so will result in the product of each variable combination being its own environment.","title":"Matrix"},{"location":"config/environment/#naming","text":"The name of the generated environments will be the variable values of each combination separated by hyphens, altogether prefixed by <ENV_NAME>. . For example, the following configuration: pyproject.toml hatch.toml [[tool.hatch.envs.test.matrix]] version = [ \"42\" ] features = [ \"foo\" , \"bar\" ] [[envs.test.matrix]] version = [ \"42\" ] features = [ \"foo\" , \"bar\" ] would indicate the following unique environments: test.42-foo test.42-bar The two exceptions to this format are described below.","title":"Naming"},{"location":"config/environment/#python-variables","text":"If the variables py or python are specified, then they will rank first in the product result and will be prefixed by py if the value is not. For example, the following configuration: pyproject.toml hatch.toml [[tool.hatch.envs.test.matrix]] version = [ \"42\" ] python = [ \"39\" , \"pypy3\" ] [[envs.test.matrix]] version = [ \"42\" ] python = [ \"39\" , \"pypy3\" ] would generate the following environments: test.py39-42 test.pypy3-42 Note The value of this variable sets the Python version .","title":"Python variables"},{"location":"config/environment/#default-environment","text":"If the default environment defines matrices, then the generated names will not be prefixed by the environment name. This can be useful for projects that only need a single series of matrices without any standalone environments.","title":"Default environment"},{"location":"config/environment/#selection","text":"Rather than selecting a single generated environment, you can select the root environment to target all of them. For example, if you have the following configuration: pyproject.toml hatch.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , ] [tool.hatch.envs.test.scripts] cov = 'pytest --cov-report=term-missing --cov=pkg --cov=tests' [[tool.hatch.envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] [envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , ] [envs.test.scripts] cov = 'pytest --cov-report=term-missing --cov=pkg --cov=tests' [[envs.test.matrix]] python = [ \"27\" , \"38\" ] version = [ \"42\" , \"3.14\" ] you could then run your tests consecutively in all 4 environments with: hatch run test:cov","title":"Selection"},{"location":"config/environment/#variable-options","text":"The variables used to generate each environment can be used to modify options within using the vars option in the root environment. The syntax uses dotted keys : vars . < VARIABLE > . < OPTION > = < VALUE > The type of the selected option determines the types of values.","title":"Variable options"},{"location":"config/environment/#mapping-types","text":"Mapping types like environment variables can have keys set using a string, or an array of strings or inline tables. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . env-vars = \"KEY=VALUE\" vars . bar . env-vars = [ \"KEY1=VALUE1\" , { key = \"KEY2\" , value = \"VALUE2\" }, ] [envs.test] vars . foo . env-vars = \"KEY=VALUE\" vars . bar . env-vars = [ \"KEY1=VALUE1\" , { key = \"KEY2\" , value = \"VALUE2\" }, ] If the value is missing (no = for strings, no value key for inline tables), then the value will be set to the value of the variable used to generate the environment.","title":"Mapping types"},{"location":"config/environment/#array-types","text":"Array types like dependencies or commands can be appended to using an array of strings or inline tables. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . dependencies = [ \"httpx\" , { value = \"cryptography\" }, ] [envs.test] vars . foo . dependencies = [ \"httpx\" , { value = \"cryptography\" }, ]","title":"Array types"},{"location":"config/environment/#string-types","text":"String types like the Python version or environment type can be set using a string or an inline table. For example: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . python = \"310\" vars . bar . python = { value = \"38\" } [envs.test] vars . foo . python = \"310\" vars . bar . python = { value = \"38\" }","title":"String types"},{"location":"config/environment/#overwriting","text":"Rather than supplementing the values within mapping types or array types , you can overwrite the option as a whole by prefixing the name with set- : pyproject.toml hatch.toml [tool.hatch.envs.test] vars . foo . set-platforms = [ \"macos\" , \"linux\" ] [envs.test] vars . foo . set-platforms = [ \"macos\" , \"linux\" ]","title":"Overwriting"},{"location":"config/environment/#conditions","text":"You may specify certain extra keys for any inline table that will determine whether or not to apply that entry.","title":"Conditions"},{"location":"config/environment/#allowed-values","text":"The if key represents the allowed values for that variable. If the value of the variable used to generate the environment is not listed, then that entry will not be applied: pyproject.toml hatch.toml [tool.hatch.envs.test] vars . version . python = { value = \"pypy\" , if = [ \"3.14\" ] } vars . version . env-vars = [ { key = \"KEY1\" , value = \"VALUE1\" , if = [ \"42\" ] }, { key = \"KEY2\" , value = \"VALUE2\" , if = [ \"3.14\" ] }, ] [[tool.hatch.envs.test.matrix]] version = [ \"42\" , \"3.14\" ] [envs.test] vars . version . python = { value = \"pypy\" , if = [ \"3.14\" ] } vars . version . env-vars = [ { key = \"KEY1\" , value = \"VALUE1\" , if = [ \"42\" ] }, { key = \"KEY2\" , value = \"VALUE2\" , if = [ \"3.14\" ] }, ] [[envs.test.matrix]] version = [ \"42\" , \"3.14\" ]","title":"Allowed values"},{"location":"config/hatch/","text":"Hatch configuration \u00b6 Configuration for Hatch itself is stored in a config.toml file located by default in one of the following platform-specific directories. Platform Path macOS ~/Library/Preferences/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_CONFIG_HOME/hatch (the XDG_CONFIG_HOME environment variable default is ~/.config ) You can select a custom path to the file using the --config root option or by setting the HATCH_CONFIG environment variable. The file can be managed by the config command group. Mode \u00b6 The mode key controls how Hatch selects the project to work on. Local \u00b6 config.toml mode = \"local\" By default, Hatch will look for a pyproject.toml or setup.py file in the current working directory and any parent directories. The directory storing the first found file will be considered the project root. Project \u00b6 config.toml mode = \"project\" project = \"proj1\" [projects] proj1 = \"/path/to/project1\" proj2 = { \"location\" : \"/path/to/project2\" } [dirs] project = [ \"/path/to/monorepo1\" , \"/path/to/monorepo2\" ] In this mode, Hatch will only work on the selected project . The project is located using multiple heuristics: If the project is defined in the projects table then it must be a string, or an inline table with a location key, that is the full path to the project. If the project matches a subdirectory in any of the directories listed in dirs.project , then that will be used as the project root. An error will occur if the project cannot be found. You can use the config set command to change the project you are working on: $ hatch config set project proj2 New setting: project = \"proj2\" Aware \u00b6 config.toml mode = \"aware\" This is essentially the local mode with a fallback to the project mode. Shell \u00b6 You can control the shell used to enter environments with the shell key. If defined as a string, it must be the name of one of the supported shells and be available along your PATH . config.toml shell = \"fish\" If the executable name of your shell differs from the supported name, you can define the shell as a table with name and path keys. config.toml [shell] name = \"powershell\" path = \"pwsh\" Supported \u00b6 Shell Name macOS Windows Unix Bash bash Command Prompt cmd C shell csh fish fish Nushell nu PowerShell powershell tcsh tcsh xonsh xonsh Z shell zsh Default \u00b6 On Windows systems Hatch will use the COMSPEC environment variable, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash . Directories \u00b6 Data \u00b6 config.toml [dirs] data = \"...\" This is the directory that is used to persist data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Application Support/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_DATA_HOME/hatch (the XDG_DATA_HOME environment variable default is ~/.local/share ) You can select a custom path to the directory using the --data-dir root option or by setting the HATCH_DATA_DIR environment variable. Cache \u00b6 config.toml [dirs] cache = \"...\" This is the directory that is used to cache data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Caches/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch\\Cache Unix $XDG_CACHE_HOME/hatch (the XDG_CACHE_HOME environment variable default is ~/.cache ) You can select a custom path to the directory using the --cache-dir root option or by setting the HATCH_CACHE_DIR environment variable. Environments \u00b6 config.toml [dirs] env = \"...\" This determines where to store environments, with the full path being <VALUE>/env/<ENV_TYPE> . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/env/<ENV_TYPE> local <PROJECT_ROOT>/.env/<ENV_TYPE> Python installations \u00b6 config.toml [dirs] python = \"...\" This determines where to install specific versions of Python, with the full path being <VALUE>/pythons . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/pythons shared ~/.pythons Terminal \u00b6 You can configure how all output types are displayed using the terminal table. These settings are also applied to all plugins. config.toml [terminal] error = \"...\" ... The types of output are as follows. Note that the verbosity indicates the minimum level at which the output is displayed. Type Default Verbosity Description debug bold 1 - 3 Messages that are not useful for most user experiences error bold_red -2 Messages indicating some unrecoverable error info bold 0 Messages conveying basic information success bold_cyan 0 Messages indicating some positive outcome waiting bold_magenta 0 Messages shown before potentially time consuming operations warning bold_yellow -1 Messages conveying important information See the full color chart and the subsequent sections for guidance on valid values.","title":"Hatch"},{"location":"config/hatch/#hatch-configuration","text":"Configuration for Hatch itself is stored in a config.toml file located by default in one of the following platform-specific directories. Platform Path macOS ~/Library/Preferences/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_CONFIG_HOME/hatch (the XDG_CONFIG_HOME environment variable default is ~/.config ) You can select a custom path to the file using the --config root option or by setting the HATCH_CONFIG environment variable. The file can be managed by the config command group.","title":"Hatch configuration"},{"location":"config/hatch/#mode","text":"The mode key controls how Hatch selects the project to work on.","title":"Mode"},{"location":"config/hatch/#local","text":"config.toml mode = \"local\" By default, Hatch will look for a pyproject.toml or setup.py file in the current working directory and any parent directories. The directory storing the first found file will be considered the project root.","title":"Local"},{"location":"config/hatch/#project","text":"config.toml mode = \"project\" project = \"proj1\" [projects] proj1 = \"/path/to/project1\" proj2 = { \"location\" : \"/path/to/project2\" } [dirs] project = [ \"/path/to/monorepo1\" , \"/path/to/monorepo2\" ] In this mode, Hatch will only work on the selected project . The project is located using multiple heuristics: If the project is defined in the projects table then it must be a string, or an inline table with a location key, that is the full path to the project. If the project matches a subdirectory in any of the directories listed in dirs.project , then that will be used as the project root. An error will occur if the project cannot be found. You can use the config set command to change the project you are working on: $ hatch config set project proj2 New setting: project = \"proj2\"","title":"Project"},{"location":"config/hatch/#aware","text":"config.toml mode = \"aware\" This is essentially the local mode with a fallback to the project mode.","title":"Aware"},{"location":"config/hatch/#shell","text":"You can control the shell used to enter environments with the shell key. If defined as a string, it must be the name of one of the supported shells and be available along your PATH . config.toml shell = \"fish\" If the executable name of your shell differs from the supported name, you can define the shell as a table with name and path keys. config.toml [shell] name = \"powershell\" path = \"pwsh\"","title":"Shell"},{"location":"config/hatch/#supported","text":"Shell Name macOS Windows Unix Bash bash Command Prompt cmd C shell csh fish fish Nushell nu PowerShell powershell tcsh tcsh xonsh xonsh Z shell zsh","title":"Supported"},{"location":"config/hatch/#default","text":"On Windows systems Hatch will use the COMSPEC environment variable, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash .","title":"Default"},{"location":"config/hatch/#directories","text":"","title":"Directories"},{"location":"config/hatch/#data","text":"config.toml [dirs] data = \"...\" This is the directory that is used to persist data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Application Support/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_DATA_HOME/hatch (the XDG_DATA_HOME environment variable default is ~/.local/share ) You can select a custom path to the directory using the --data-dir root option or by setting the HATCH_DATA_DIR environment variable.","title":"Data"},{"location":"config/hatch/#cache","text":"config.toml [dirs] cache = \"...\" This is the directory that is used to cache data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Caches/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch\\Cache Unix $XDG_CACHE_HOME/hatch (the XDG_CACHE_HOME environment variable default is ~/.cache ) You can select a custom path to the directory using the --cache-dir root option or by setting the HATCH_CACHE_DIR environment variable.","title":"Cache"},{"location":"config/hatch/#environments","text":"config.toml [dirs] env = \"...\" This determines where to store environments, with the full path being <VALUE>/env/<ENV_TYPE> . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/env/<ENV_TYPE> local <PROJECT_ROOT>/.env/<ENV_TYPE>","title":"Environments"},{"location":"config/hatch/#python-installations","text":"config.toml [dirs] python = \"...\" This determines where to install specific versions of Python, with the full path being <VALUE>/pythons . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/pythons shared ~/.pythons","title":"Python installations"},{"location":"config/hatch/#terminal","text":"You can configure how all output types are displayed using the terminal table. These settings are also applied to all plugins. config.toml [terminal] error = \"...\" ... The types of output are as follows. Note that the verbosity indicates the minimum level at which the output is displayed. Type Default Verbosity Description debug bold 1 - 3 Messages that are not useful for most user experiences error bold_red -2 Messages indicating some unrecoverable error info bold 0 Messages conveying basic information success bold_cyan 0 Messages indicating some positive outcome waiting bold_magenta 0 Messages shown before potentially time consuming operations warning bold_yellow -1 Messages conveying important information See the full color chart and the subsequent sections for guidance on valid values.","title":"Terminal"},{"location":"config/metadata/","text":"Project metadata \u00b6 Project metadata is stored in a pyproject.toml file located at the root of a project's tree and is based entirely on PEP 621 . Name ( required ) \u00b6 The name of the project. pyproject.toml [project] name = \"your-app\" Version ( required ) \u00b6 pyproject.toml Dynamic Static See the dedicated versioning section. [project] ... dynamic = [ \"version\" ] [tool.hatch.version] path = \"...\" [project] ... version = \"0.0.1\" Description \u00b6 A brief summary of the project. pyproject.toml [project] ... description = '...' Readme \u00b6 The full description of the project. pyproject.toml Simple Complex The file extension must be .md or .rst . [project] ... readme = \"README.md\" The content_type field must be set to text/markdown or text/x-rst . File Text A charset field may also be set to instruct which encoding to use for reading the file, defaulting to utf-8 . [project] ... readme = { \"file\" : \"README.md\" , \"content_type\" : \"text/markdown\" } The content_type field must be set to text/markdown or text/x-rst . [project] ... readme = { \"text\" : \"...\" , \"content_type\" : \"text/markdown\" } Note If this is defined as a file, then it will always be included in source distributions for consistent builds. Python support \u00b6 The Python version requirements of the project. pyproject.toml [project] ... requires-python = \">=3.8\" License \u00b6 pyproject.toml SPDX identifier Custom For more information, see PEP 639 . [project] ... license = \"Apache-2.0 or MIT\" File Text [project] ... license = { \"file\" : \"LICENSE.txt\" } [project] ... license = { \"text\" : \"...\" } Ownership \u00b6 The people or organizations considered to be the authors or maintainers of the project. The exact meaning is open to interpretation; it may list the original or primary authors, current maintainers, or owners of the package. If the values are the same, prefer only the use of the authors field. pyproject.toml [project] ... authors = [ { name = \"...\" , email = \"...\" }, ] maintainers = [ { name = \"...\" , email = \"...\" }, ] Keywords \u00b6 The keywords used to assist in the discovery of the project. pyproject.toml [project] ... keywords = [ \"...\" , ] Classifiers \u00b6 The trove classifiers that apply to the project. pyproject.toml [project] ... classifiers = [ \"...\" , ] URLs \u00b6 A table of URLs where the key is the URL label and the value is the URL itself. pyproject.toml [project.urls] Documentation = \"...\" \"Source code\" = \"...\" Dependencies \u00b6 The format is based on PEP 631 . See the dependency specification section for more information. Required \u00b6 pyproject.toml [project] ... dependencies = [ \"...\" , ] Optional \u00b6 pyproject.toml [project.optional-dependencies] option1 = [ \"...\" , ] option2 = [ \"...\" , ] Entry points \u00b6 Entry points are a mechanism for the project to advertise components it provides to be discovered and used by other code. CLI \u00b6 pyproject.toml [project.scripts] cli-name = \"pkg.subpkg:func\" GUI \u00b6 pyproject.toml [project.gui-scripts] gui-name = \"pkg.subpkg:func\" Plugins \u00b6 pyproject.toml [project.entry-points.plugin-namespace] plugin-name1 = \"pkg.subpkg1\" plugin-name2 = \"pkg.subpkg2:func\"","title":"Metadata"},{"location":"config/metadata/#project-metadata","text":"Project metadata is stored in a pyproject.toml file located at the root of a project's tree and is based entirely on PEP 621 .","title":"Project metadata"},{"location":"config/metadata/#name","text":"The name of the project. pyproject.toml [project] name = \"your-app\"","title":"Name (required)"},{"location":"config/metadata/#version","text":"pyproject.toml Dynamic Static See the dedicated versioning section. [project] ... dynamic = [ \"version\" ] [tool.hatch.version] path = \"...\" [project] ... version = \"0.0.1\"","title":"Version (required)"},{"location":"config/metadata/#description","text":"A brief summary of the project. pyproject.toml [project] ... description = '...'","title":"Description"},{"location":"config/metadata/#readme","text":"The full description of the project. pyproject.toml Simple Complex The file extension must be .md or .rst . [project] ... readme = \"README.md\" The content_type field must be set to text/markdown or text/x-rst . File Text A charset field may also be set to instruct which encoding to use for reading the file, defaulting to utf-8 . [project] ... readme = { \"file\" : \"README.md\" , \"content_type\" : \"text/markdown\" } The content_type field must be set to text/markdown or text/x-rst . [project] ... readme = { \"text\" : \"...\" , \"content_type\" : \"text/markdown\" } Note If this is defined as a file, then it will always be included in source distributions for consistent builds.","title":"Readme"},{"location":"config/metadata/#python-support","text":"The Python version requirements of the project. pyproject.toml [project] ... requires-python = \">=3.8\"","title":"Python support"},{"location":"config/metadata/#license","text":"pyproject.toml SPDX identifier Custom For more information, see PEP 639 . [project] ... license = \"Apache-2.0 or MIT\" File Text [project] ... license = { \"file\" : \"LICENSE.txt\" } [project] ... license = { \"text\" : \"...\" }","title":"License"},{"location":"config/metadata/#ownership","text":"The people or organizations considered to be the authors or maintainers of the project. The exact meaning is open to interpretation; it may list the original or primary authors, current maintainers, or owners of the package. If the values are the same, prefer only the use of the authors field. pyproject.toml [project] ... authors = [ { name = \"...\" , email = \"...\" }, ] maintainers = [ { name = \"...\" , email = \"...\" }, ]","title":"Ownership"},{"location":"config/metadata/#keywords","text":"The keywords used to assist in the discovery of the project. pyproject.toml [project] ... keywords = [ \"...\" , ]","title":"Keywords"},{"location":"config/metadata/#classifiers","text":"The trove classifiers that apply to the project. pyproject.toml [project] ... classifiers = [ \"...\" , ]","title":"Classifiers"},{"location":"config/metadata/#urls","text":"A table of URLs where the key is the URL label and the value is the URL itself. pyproject.toml [project.urls] Documentation = \"...\" \"Source code\" = \"...\"","title":"URLs"},{"location":"config/metadata/#dependencies","text":"The format is based on PEP 631 . See the dependency specification section for more information.","title":"Dependencies"},{"location":"config/metadata/#required","text":"pyproject.toml [project] ... dependencies = [ \"...\" , ]","title":"Required"},{"location":"config/metadata/#optional","text":"pyproject.toml [project.optional-dependencies] option1 = [ \"...\" , ] option2 = [ \"...\" , ]","title":"Optional"},{"location":"config/metadata/#entry-points","text":"Entry points are a mechanism for the project to advertise components it provides to be discovered and used by other code.","title":"Entry points"},{"location":"config/metadata/#cli","text":"pyproject.toml [project.scripts] cli-name = \"pkg.subpkg:func\"","title":"CLI"},{"location":"config/metadata/#gui","text":"pyproject.toml [project.gui-scripts] gui-name = \"pkg.subpkg:func\"","title":"GUI"},{"location":"config/metadata/#plugins","text":"pyproject.toml [project.entry-points.plugin-namespace] plugin-name1 = \"pkg.subpkg1\" plugin-name2 = \"pkg.subpkg2:func\"","title":"Plugins"},{"location":"plugins/about/","text":"Plugins \u00b6 Hatch utilizes pluggy for its plugin functionality. Overview \u00b6 All plugins provide registration hooks that return one or more classes that inherit from a particular type interface. Each registration hook must be decorated by Hatch's hook marker. For example, if you wanted to create a new kind of environment you could do: hooks.py from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment The hooks can return a single class or a list of classes. Every class must define an attribute called PLUGIN_NAME that users will select when they wish to use the plugin. So in the example above, the class might be defined like: plugin.py ... class SpecialEnvironment ( ... ): PLUGIN_NAME = 'special' ... Project configuration \u00b6 Naming \u00b6 It is recommended that plugin project names are prefixed with hatch- . For example, if you wanted to make a plugin that provides some functionality for a product named foo you might do: pyproject.toml [project] name = \"hatch-foo\" Discovery \u00b6 You'll need to define your project as a Python plugin for Hatch: pyproject.toml [project.entry-points.hatch] foo = \"pkg.hooks\" The name of the plugin should be the project name (excluding any hatch- prefix) and the path should represent the module that contains the registration hooks. Types \u00b6 Hatchling \u00b6 These are all involved in building projects and therefore any defined dependencies are automatically installed in each build environment. Builder Build hook Metadata hook Version source Hatch \u00b6 These must be manually installed in the same environment as Hatch itself. Environment Publisher Version scheme","title":"About"},{"location":"plugins/about/#plugins","text":"Hatch utilizes pluggy for its plugin functionality.","title":"Plugins"},{"location":"plugins/about/#overview","text":"All plugins provide registration hooks that return one or more classes that inherit from a particular type interface. Each registration hook must be decorated by Hatch's hook marker. For example, if you wanted to create a new kind of environment you could do: hooks.py from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment The hooks can return a single class or a list of classes. Every class must define an attribute called PLUGIN_NAME that users will select when they wish to use the plugin. So in the example above, the class might be defined like: plugin.py ... class SpecialEnvironment ( ... ): PLUGIN_NAME = 'special' ...","title":"Overview"},{"location":"plugins/about/#project-configuration","text":"","title":"Project configuration"},{"location":"plugins/about/#naming","text":"It is recommended that plugin project names are prefixed with hatch- . For example, if you wanted to make a plugin that provides some functionality for a product named foo you might do: pyproject.toml [project] name = \"hatch-foo\"","title":"Naming"},{"location":"plugins/about/#discovery","text":"You'll need to define your project as a Python plugin for Hatch: pyproject.toml [project.entry-points.hatch] foo = \"pkg.hooks\" The name of the plugin should be the project name (excluding any hatch- prefix) and the path should represent the module that contains the registration hooks.","title":"Discovery"},{"location":"plugins/about/#types","text":"","title":"Types"},{"location":"plugins/about/#hatchling","text":"These are all involved in building projects and therefore any defined dependencies are automatically installed in each build environment. Builder Build hook Metadata hook Version source","title":"Hatchling"},{"location":"plugins/about/#hatch","text":"These must be manually installed in the same environment as Hatch itself. Environment Publisher Version scheme","title":"Hatch"},{"location":"plugins/build-hook/","text":"Build hook plugins \u00b6 A build hook provides code that will be executed at various stages of the build process. See the documentation for build hook configuration . Overview \u00b6 Build hooks run for every selected version of build targets. The initialization stage occurs immediately before each build and the finalization stage occurs immediately after. Each stage has the opportunity to view or modify build data . Build data \u00b6 Build data is a simple mapping whose contents can influence the behavior of builds. Which fields are recognized depends on each build target. The following fields are always present and recognized by the build system itself: Field Type Description artifacts list [ str ] This is a list of extra paths to artifacts and should generally only be appended to Built-in \u00b6 Custom \u00b6 This is a custom class in a given Python file that inherits from the BuildHookInterface . Configuration \u00b6 The build hook plugin name is custom . pyproject.toml hatch.toml [tool.hatch.build.hooks.custom] [tool.hatch.build.targets.<TARGET_NAME>.hooks.custom] [build.hooks.custom] [build.targets.<TARGET_NAME>.hooks.custom] An option path is used to specify the path of the Python file, defaulting to build.py . Example \u00b6 build.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class CustomBuildHook ( BuildHookInterface ): ... If multiple subclasses are found, you must define a function named get_build_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom . BuildHookInterface \u00b6 Example usage: plugin.py hooks.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class SpecialBuildHook ( BuildHookInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialBuildHook @hookimpl def hatch_register_build_hook (): return SpecialBuildHook PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . config property readonly \u00b6 The cumulative hook configuration. pyproject.toml hatch.toml [tool.hatch.build.hooks.<PLUGIN_NAME>] [tool.hatch.build.targets.<TARGET_NAME>.hooks.<PLUGIN_NAME>] [build.hooks.<PLUGIN_NAME>] [build.targets.<TARGET_NAME>.hooks.<PLUGIN_NAME>] directory property readonly \u00b6 The build directory. root property readonly \u00b6 The root of the project tree. target_name property readonly \u00b6 The plugin name of the build target. finalize ( self , version , build_data , artifact_path ) \u00b6 This occurs immediately after each build and will not run if the --hooks-only flag was passed to the build command. The build data will reflect any modifications done by the target during the build. Source code in hatchling/builders/hooks/plugin/interface.py def finalize ( self , version , build_data , artifact_path ): \"\"\" This occurs immediately after each build and will not run if the `--hooks-only` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. The build data will reflect any modifications done by the target during the build. \"\"\" initialize ( self , version , build_data ) \u00b6 This occurs immediately before each build. Any modifications to the build data will be seen by the build target. Source code in hatchling/builders/hooks/plugin/interface.py def initialize ( self , version , build_data ): \"\"\" This occurs immediately before each build. Any modifications to the build data will be seen by the build target. \"\"\"","title":"Build hook"},{"location":"plugins/build-hook/#build-hook-plugins","text":"A build hook provides code that will be executed at various stages of the build process. See the documentation for build hook configuration .","title":"Build hook plugins"},{"location":"plugins/build-hook/#overview","text":"Build hooks run for every selected version of build targets. The initialization stage occurs immediately before each build and the finalization stage occurs immediately after. Each stage has the opportunity to view or modify build data .","title":"Overview"},{"location":"plugins/build-hook/#build-data","text":"Build data is a simple mapping whose contents can influence the behavior of builds. Which fields are recognized depends on each build target. The following fields are always present and recognized by the build system itself: Field Type Description artifacts list [ str ] This is a list of extra paths to artifacts and should generally only be appended to","title":"Build data"},{"location":"plugins/build-hook/#built-in","text":"","title":"Built-in"},{"location":"plugins/build-hook/#custom","text":"This is a custom class in a given Python file that inherits from the BuildHookInterface .","title":"Custom"},{"location":"plugins/build-hook/#configuration","text":"The build hook plugin name is custom . pyproject.toml hatch.toml [tool.hatch.build.hooks.custom] [tool.hatch.build.targets.<TARGET_NAME>.hooks.custom] [build.hooks.custom] [build.targets.<TARGET_NAME>.hooks.custom] An option path is used to specify the path of the Python file, defaulting to build.py .","title":"Configuration"},{"location":"plugins/build-hook/#example","text":"build.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class CustomBuildHook ( BuildHookInterface ): ... If multiple subclasses are found, you must define a function named get_build_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom .","title":"Example"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface","text":"Example usage: plugin.py hooks.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class SpecialBuildHook ( BuildHookInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialBuildHook @hookimpl def hatch_register_build_hook (): return SpecialBuildHook","title":"BuildHookInterface"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.config","text":"The cumulative hook configuration. pyproject.toml hatch.toml [tool.hatch.build.hooks.<PLUGIN_NAME>] [tool.hatch.build.targets.<TARGET_NAME>.hooks.<PLUGIN_NAME>] [build.hooks.<PLUGIN_NAME>] [build.targets.<TARGET_NAME>.hooks.<PLUGIN_NAME>]","title":"config"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.directory","text":"The build directory.","title":"directory"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.root","text":"The root of the project tree.","title":"root"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.target_name","text":"The plugin name of the build target.","title":"target_name"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.finalize","text":"This occurs immediately after each build and will not run if the --hooks-only flag was passed to the build command. The build data will reflect any modifications done by the target during the build. Source code in hatchling/builders/hooks/plugin/interface.py def finalize ( self , version , build_data , artifact_path ): \"\"\" This occurs immediately after each build and will not run if the `--hooks-only` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. The build data will reflect any modifications done by the target during the build. \"\"\"","title":"finalize()"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.initialize","text":"This occurs immediately before each build. Any modifications to the build data will be seen by the build target. Source code in hatchling/builders/hooks/plugin/interface.py def initialize ( self , version , build_data ): \"\"\" This occurs immediately before each build. Any modifications to the build data will be seen by the build target. \"\"\"","title":"initialize()"},{"location":"plugins/builder/","text":"Builder plugins \u00b6 See the documentation for build configuration . Built-in \u00b6 Wheel \u00b6 A wheel is a binary distribution of a Python package that can be installed directly into an environment. Configuration \u00b6 The builder plugin name is wheel . pyproject.toml hatch.toml [tool.hatch.build.targets.wheel] [build.targets.wheel] Extra options \u00b6 Option Default Description zip-safe true Whether or not to write metadata indicating that the package is able to run directly as a ZIP file; can be overriden by build hooks core-metadata-version \"2.1\" The version of core metadata to use Tip The zip-safe option must be set to false for packages that indicate PEP 561 typing support with a py.typed file. Versions \u00b6 Version Description standard (default) The latest standardized format Default file selection \u00b6 When the user has not set any file selection options, every file will be included that is inside any Python package that does not start with the word test . Caveat Native namespace packages would not be included by default because one of the heuristics that is used is the presence of a __init__.py file. Build data \u00b6 This is data that can be modified by build hooks . Data Default Description tag The full tag part of the filename (e.g. py3-none-any ), defaulting to a cross-platform wheel with the supported major versions of Python based on project metadata infer_tag False When tag is not set, this may be enabled to use the one most specific to the platform, Python interpreter, and ABI zip_safe Whether or not to write metadata indicating that the package is able to run directly as a ZIP file, defaulting to the zip-safe option Source distribution \u00b6 A source distribution, or sdist , is an archive of Python \"source code\". Although largely unspecified, by convention it should include everything that is required to build a wheel without making network requests. Configuration \u00b6 The builder plugin name is sdist . pyproject.toml hatch.toml [tool.hatch.build.targets.sdist] [build.targets.sdist] Extra options \u00b6 Option Default Description support-legacy true Whether or not to include a setup.py file to support legacy installation mechanisms core-metadata-version \"1.2\" The version of core metadata to use Versions \u00b6 Version Description standard (default) The latest conventional format Default file selection \u00b6 When the user has not set any file selection options, all files that are not ignored by your VCS will be included. Custom \u00b6 This is a custom class in a given Python file that inherits from the BuilderInterface . Configuration \u00b6 The builder plugin name is custom . pyproject.toml hatch.toml [tool.hatch.build.targets.custom] [build.targets.custom] An option path is used to specify the path of the Python file, defaulting to build.py . Example \u00b6 build.py from hatchling.builders.plugin.interface import BuilderInterface class CustomBuilder ( BuilderInterface ): ... If multiple subclasses are found, you must define a function named get_builder that returns the desired builder. Note Any defined PLUGIN_NAME is ignored and will always be custom . BuilderInterface \u00b6 Example usage: plugin.py hooks.py from hatchling.builders.plugin.interface import BuilderInterface class SpecialBuilder ( BuilderInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialBuilder @hookimpl def hatch_register_builder (): return SpecialBuilder PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . build_config property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.build] [build] dev_mode_dirs property readonly \u00b6 Directories which must be added to Python's search path in dev mode . reproducible property readonly \u00b6 Whether or not the target should be built in a reproducible manner, defaulting to true. root property readonly \u00b6 The root of the project tree. target_config property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.build.targets.<PLUGIN_NAME>] [build.targets.<PLUGIN_NAME>] clean ( self , directory , versions ) \u00b6 Called before builds if the -c / --clean flag was passed to the build command. Source code in hatchling/builders/plugin/interface.py def clean ( self , directory , versions ): \"\"\" Called before builds if the `-c`/`--clean` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. \"\"\" get_default_build_data ( self ) \u00b6 A mapping that can be modified by build hooks to influence the behavior of builds. Source code in hatchling/builders/plugin/interface.py def get_default_build_data ( self ): \"\"\" A mapping that can be modified by [build hooks](build-hook.md) to influence the behavior of builds. \"\"\" return {} get_default_versions ( self ) \u00b6 A list of versions to build when users do not specify any, defaulting to all versions. Source code in hatchling/builders/plugin/interface.py def get_default_versions ( self ): \"\"\" A list of versions to build when users do not specify any, defaulting to all versions. \"\"\" return list ( self . get_version_api ()) get_version_api ( self ) \u00b6 REQUIRED A mapping of str versions to a callable that is used for building. Each callable must have the following signature: def ... ( build_dir : str , build_data : dict ) -> str : The return value must be the absolute path to the built artifact. Source code in hatchling/builders/plugin/interface.py def get_version_api ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: A mapping of `str` versions to a callable that is used for building. Each callable must have the following signature: ```python def ...(build_dir: str, build_data: dict) -> str: ``` The return value must be the absolute path to the built artifact. \"\"\" raise NotImplementedError recurse_project_files ( self ) \u00b6 Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three str attributes: path - the absolute path relative_path - the path relative to the project root distribution_path - the path to be distributed as Source code in hatchling/builders/plugin/interface.py def recurse_project_files ( self ): \"\"\" Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three `str` attributes: - `path` - the absolute path - `relative_path` - the path relative to the project root - `distribution_path` - the path to be distributed as \"\"\" for root , dirs , files in os . walk ( self . root ): relative_path = os . path . relpath ( root , self . root ) # First iteration if relative_path == '.' : relative_path = '' dirs [:] = sorted ( d for d in dirs if not ( self . ignore_directory ( d ) # The trailing slash is necessary so e.g. `bar/` matches `foo/bar` or self . path_is_excluded ( ' {} /' . format ( os . path . join ( relative_path , d ))) ) ) if self . ignore_files ( files ): continue for f in sorted ( files ): relative_file_path = os . path . join ( relative_path , f ) if self . include_path ( relative_file_path ): yield IncludedFile ( os . path . join ( root , f ), relative_file_path , self . get_distribution_path ( relative_file_path ) )","title":"Builder"},{"location":"plugins/builder/#builder-plugins","text":"See the documentation for build configuration .","title":"Builder plugins"},{"location":"plugins/builder/#built-in","text":"","title":"Built-in"},{"location":"plugins/builder/#wheel","text":"A wheel is a binary distribution of a Python package that can be installed directly into an environment.","title":"Wheel"},{"location":"plugins/builder/#configuration","text":"The builder plugin name is wheel . pyproject.toml hatch.toml [tool.hatch.build.targets.wheel] [build.targets.wheel]","title":"Configuration"},{"location":"plugins/builder/#extra-options","text":"Option Default Description zip-safe true Whether or not to write metadata indicating that the package is able to run directly as a ZIP file; can be overriden by build hooks core-metadata-version \"2.1\" The version of core metadata to use Tip The zip-safe option must be set to false for packages that indicate PEP 561 typing support with a py.typed file.","title":"Extra options"},{"location":"plugins/builder/#versions","text":"Version Description standard (default) The latest standardized format","title":"Versions"},{"location":"plugins/builder/#default-file-selection","text":"When the user has not set any file selection options, every file will be included that is inside any Python package that does not start with the word test . Caveat Native namespace packages would not be included by default because one of the heuristics that is used is the presence of a __init__.py file.","title":"Default file selection"},{"location":"plugins/builder/#build-data","text":"This is data that can be modified by build hooks . Data Default Description tag The full tag part of the filename (e.g. py3-none-any ), defaulting to a cross-platform wheel with the supported major versions of Python based on project metadata infer_tag False When tag is not set, this may be enabled to use the one most specific to the platform, Python interpreter, and ABI zip_safe Whether or not to write metadata indicating that the package is able to run directly as a ZIP file, defaulting to the zip-safe option","title":"Build data"},{"location":"plugins/builder/#source-distribution","text":"A source distribution, or sdist , is an archive of Python \"source code\". Although largely unspecified, by convention it should include everything that is required to build a wheel without making network requests.","title":"Source distribution"},{"location":"plugins/builder/#configuration_1","text":"The builder plugin name is sdist . pyproject.toml hatch.toml [tool.hatch.build.targets.sdist] [build.targets.sdist]","title":"Configuration"},{"location":"plugins/builder/#extra-options_1","text":"Option Default Description support-legacy true Whether or not to include a setup.py file to support legacy installation mechanisms core-metadata-version \"1.2\" The version of core metadata to use","title":"Extra options"},{"location":"plugins/builder/#versions_1","text":"Version Description standard (default) The latest conventional format","title":"Versions"},{"location":"plugins/builder/#default-file-selection_1","text":"When the user has not set any file selection options, all files that are not ignored by your VCS will be included.","title":"Default file selection"},{"location":"plugins/builder/#custom","text":"This is a custom class in a given Python file that inherits from the BuilderInterface .","title":"Custom"},{"location":"plugins/builder/#configuration_2","text":"The builder plugin name is custom . pyproject.toml hatch.toml [tool.hatch.build.targets.custom] [build.targets.custom] An option path is used to specify the path of the Python file, defaulting to build.py .","title":"Configuration"},{"location":"plugins/builder/#example","text":"build.py from hatchling.builders.plugin.interface import BuilderInterface class CustomBuilder ( BuilderInterface ): ... If multiple subclasses are found, you must define a function named get_builder that returns the desired builder. Note Any defined PLUGIN_NAME is ignored and will always be custom .","title":"Example"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface","text":"Example usage: plugin.py hooks.py from hatchling.builders.plugin.interface import BuilderInterface class SpecialBuilder ( BuilderInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialBuilder @hookimpl def hatch_register_builder (): return SpecialBuilder","title":"BuilderInterface"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.build_config","text":"pyproject.toml hatch.toml [tool.hatch.build] [build]","title":"build_config"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.dev_mode_dirs","text":"Directories which must be added to Python's search path in dev mode .","title":"dev_mode_dirs"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.reproducible","text":"Whether or not the target should be built in a reproducible manner, defaulting to true.","title":"reproducible"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.root","text":"The root of the project tree.","title":"root"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.target_config","text":"pyproject.toml hatch.toml [tool.hatch.build.targets.<PLUGIN_NAME>] [build.targets.<PLUGIN_NAME>]","title":"target_config"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.clean","text":"Called before builds if the -c / --clean flag was passed to the build command. Source code in hatchling/builders/plugin/interface.py def clean ( self , directory , versions ): \"\"\" Called before builds if the `-c`/`--clean` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. \"\"\"","title":"clean()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_default_build_data","text":"A mapping that can be modified by build hooks to influence the behavior of builds. Source code in hatchling/builders/plugin/interface.py def get_default_build_data ( self ): \"\"\" A mapping that can be modified by [build hooks](build-hook.md) to influence the behavior of builds. \"\"\" return {}","title":"get_default_build_data()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_default_versions","text":"A list of versions to build when users do not specify any, defaulting to all versions. Source code in hatchling/builders/plugin/interface.py def get_default_versions ( self ): \"\"\" A list of versions to build when users do not specify any, defaulting to all versions. \"\"\" return list ( self . get_version_api ())","title":"get_default_versions()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_version_api","text":"REQUIRED A mapping of str versions to a callable that is used for building. Each callable must have the following signature: def ... ( build_dir : str , build_data : dict ) -> str : The return value must be the absolute path to the built artifact. Source code in hatchling/builders/plugin/interface.py def get_version_api ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: A mapping of `str` versions to a callable that is used for building. Each callable must have the following signature: ```python def ...(build_dir: str, build_data: dict) -> str: ``` The return value must be the absolute path to the built artifact. \"\"\" raise NotImplementedError","title":"get_version_api()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.recurse_project_files","text":"Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three str attributes: path - the absolute path relative_path - the path relative to the project root distribution_path - the path to be distributed as Source code in hatchling/builders/plugin/interface.py def recurse_project_files ( self ): \"\"\" Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three `str` attributes: - `path` - the absolute path - `relative_path` - the path relative to the project root - `distribution_path` - the path to be distributed as \"\"\" for root , dirs , files in os . walk ( self . root ): relative_path = os . path . relpath ( root , self . root ) # First iteration if relative_path == '.' : relative_path = '' dirs [:] = sorted ( d for d in dirs if not ( self . ignore_directory ( d ) # The trailing slash is necessary so e.g. `bar/` matches `foo/bar` or self . path_is_excluded ( ' {} /' . format ( os . path . join ( relative_path , d ))) ) ) if self . ignore_files ( files ): continue for f in sorted ( files ): relative_file_path = os . path . join ( relative_path , f ) if self . include_path ( relative_file_path ): yield IncludedFile ( os . path . join ( root , f ), relative_file_path , self . get_distribution_path ( relative_file_path ) )","title":"recurse_project_files()"},{"location":"plugins/environment/","text":"Environment plugins \u00b6 See the documentation for environment configuration . Life cycle \u00b6 Whenever an environment is used, the following logic is performed: Source code in hatch/cli/application.py def prepare_environment ( self , environment ): if not environment . exists (): self . display_waiting ( f 'Creating environment: { environment . name } ' ) environment . create () if not environment . skip_install : if environment . pre_install_commands : self . display_waiting ( 'Running pre-installation commands...' ) for process in environment . run_shell_commands ( environment . pre_install_commands ): if process . returncode : self . abort ( f 'Failed with exit code: { process . returncode } ' , code = process . returncode ) if environment . dev_mode : self . display_waiting ( 'Installing project in development mode...' ) environment . install_project_dev_mode () else : self . display_waiting ( 'Installing project...' ) environment . install_project () if environment . post_install_commands : self . display_waiting ( 'Running post-installation commands...' ) for process in environment . run_shell_commands ( environment . post_install_commands ): if process . returncode : self . abort ( f 'Failed with exit code: { process . returncode } ' , code = process . returncode ) if not environment . dependencies_in_sync (): self . display_waiting ( 'Syncing dependencies...' ) environment . sync_dependencies () Built-in \u00b6 Virtual \u00b6 This uses virtual environments backed by the standard virtualenv tool. Configuration \u00b6 The environment plugin name is virtual . pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] type = \"virtual\" [envs.<ENV_NAME>] type = \"virtual\" Extra options \u00b6 Option Default Description system-packages false Whether or not to give the virtual environment access to the system site-packages directory python The version of Python to find on your system and subsequently use to create the environment, defaulting to the first python found along your PATH , followed by the Python executable Hatch is running on. For more information, see the documentation . EnvironmentInterface ( ABC ) \u00b6 Example usage: plugin.py hooks.py from hatch.env.plugin.interface import EnvironmentInterface class SpecialEnvironment ( EnvironmentInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . config : dict property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] [envs.<ENV_NAME>] data_directory property readonly \u00b6 The directory reserved exclusively for this plugin as a path-like object. dependencies : list [ str ] property readonly \u00b6 The list of all project dependencies (if installed and in dev mode ) and environment dependencies . dev_mode : bool property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] dev-mode = ... [envs.<ENV_NAME>] dev-mode = ... env_vars : dict property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>.env-vars] [envs.<ENV_NAME>.env-vars] Note The environment variable HATCH_ENV_ACTIVE will always be set to the name of the environment. name : str property readonly \u00b6 The name of the environment. platform property readonly \u00b6 An instance of Platform . platforms : list [ str ] property readonly \u00b6 All names are stored as their lower-cased version. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] platforms = [...] [envs.<ENV_NAME>] platforms = [...] root property readonly \u00b6 The root of the project tree as a path-like object. skip_install : bool property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] skip-install = ... [envs.<ENV_NAME>] skip-install = ... activate ( self ) \u00b6 A convenience method called when using the environment as a context manager: with environment : ... Source code in hatch/env/plugin/interface.py def activate ( self ): \"\"\" A convenience method called when using the environment as a context manager: ```python with environment: ... ``` \"\"\" apply_features ( self , requirement : str ) \u00b6 A convenience method that applies any user defined features to the given requirement. Source code in hatch/env/plugin/interface.py def apply_features ( self , requirement : str ): \"\"\" A convenience method that applies any user defined [features](../config/environment.md#features) to the given requirement. \"\"\" if self . features : features = ',' . join ( self . features ) return f ' { requirement } [ { features } ]' return requirement build_environment ( self , dependencies : list [ str ]) \u00b6 This should set up an isolated environment in which to build the project given a set of dependencies and must be a context manager: with environment . build_environment ([ ... ]): ... Source code in hatch/env/plugin/interface.py @contextmanager def build_environment ( self , dependencies : list [ str ]): \"\"\" This should set up an isolated environment in which to [`build`](../cli/reference.md#hatch-build) the project given a set of dependencies and must be a context manager: ```python with environment.build_environment([...]): ... ``` \"\"\" yield compatible ( self ) \u00b6 Whether or not the environment is compatible with the current user's setup. The default behavior checks for platform compatibility and any method override should keep this check. Source code in hatch/env/plugin/interface.py def compatible ( self ): \"\"\" Whether or not the environment is compatible with the current user's setup. The default behavior checks for [platform compatibility](../config/environment.md#supported-platforms) and any method override should keep this check. \"\"\" if not self . platforms : return True return self . platform . system_name in self . platforms construct_build_command ( self , * , directory = None , targets = (), clean = False , hooks_only = False ) \u00b6 This is the canonical way build command options are translated to a subprocess command issued to builders . Source code in hatch/env/plugin/interface.py def construct_build_command ( self , * , directory = None , targets = (), clean = False , hooks_only = False ): \"\"\" This is the canonical way [`build`](../cli/reference.md#hatch-build) command options are translated to a subprocess command issued to [builders](builder.md). \"\"\" command = [ 'python' , '-m' , 'hatchling' , 'build' , '--app' ] if directory : command . extend (( '--directory' , directory )) if targets : for target in targets : command . extend (( '--target' , target )) if clean : command . append ( '--clean' ) if hooks_only : command . append ( '--hooks-only' ) return command construct_pip_install_command ( self , args : list [ str ], verbosity = None ) \u00b6 A convenience method for constructing a pip install command with the given verbosity. The default verbosity is set to one less than Hatch's verbosity. Source code in hatch/env/plugin/interface.py def construct_pip_install_command ( self , args : list [ str ], verbosity = None ): \"\"\" A convenience method for constructing a [`pip install`](https://pip.pypa.io/en/stable/cli/pip_install/) command with the given verbosity. The default verbosity is set to one less than Hatch's verbosity. \"\"\" if verbosity is None : # Default to -1 verbosity verbosity = self . verbosity - 1 command = [ 'python' , '-m' , 'pip' , 'install' , '--disable-pip-version-check' ] if verbosity < 0 : command . append ( f \"- { 'q' * abs ( verbosity ) } \" ) elif verbosity > 0 : command . append ( f \"- { 'v' * abs ( verbosity ) } \" ) command . extend ( args ) return command create ( self ) \u00b6 REQUIRED This should perform the necessary steps to set up the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def create ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should perform the necessary steps to set up the environment. \"\"\" deactivate ( self ) \u00b6 A convenience method called after using the environment as a context manager: with environment : ... Source code in hatch/env/plugin/interface.py def deactivate ( self ): \"\"\" A convenience method called after using the environment as a context manager: ```python with environment: ... ``` \"\"\" dependencies_in_sync ( self ) -> bool \u00b6 REQUIRED This should indicate whether or not the environment is compatible with the current dependencies . Source code in hatch/env/plugin/interface.py @abstractmethod def dependencies_in_sync ( self ) -> bool : \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should indicate whether or not the environment is compatible with the current [dependencies](environment.md#hatch.env.plugin.interface.EnvironmentInterface.dependencies). \"\"\" enter_shell ( self , name , path ) \u00b6 Spawn a shell within the environment. The shell should reflect any environment variables the user defined either currently or at the time of creation . Source code in hatch/env/plugin/interface.py def enter_shell ( self , name , path ): \"\"\" Spawn a [shell](../config/hatch.md#shell) within the environment. The shell should reflect any [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) the user defined either currently or at the time of [creation](environment.md#hatch.env.plugin.interface.EnvironmentInterface.create). \"\"\" with self . set_env_vars (): self . platform . exit_with_command ([ path ]) exists ( self ) -> bool \u00b6 REQUIRED This should indicate whether or not the environment has already been created. Source code in hatch/env/plugin/interface.py @abstractmethod def exists ( self ) -> bool : \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should indicate whether or not the environment has already been created. \"\"\" get_build_process ( self , ** kwargs ) \u00b6 This will be called when the build environment is active: with environment . build_environment ([ ... ]): build_process = environment . get_build_process ( ... ) This should return the standard library's subprocess.Popen with all output captured by stdout . The command is constructed by passing all keyword arguments to construct_build_command . For an example, open the default implementation below: Source code in hatch/env/plugin/interface.py def get_build_process ( self , ** kwargs ): \"\"\" This will be called when the [build environment](environment.md#hatch.env.plugin.interface.EnvironmentInterface.build_environment) is active: ```python with environment.build_environment([...]): build_process = environment.get_build_process(...) ``` This should return the standard library's [subprocess.Popen](https://docs.python.org/3/library/subprocess.html#subprocess.Popen) with all output captured by `stdout`. The command is constructed by passing all keyword arguments to [construct_build_command](environment.md#hatch.env.plugin.interface.EnvironmentInterface.construct_build_command). For an example, open the default implementation below: \"\"\" return self . platform . capture_process ( self . construct_build_command ( ** kwargs )) install_project ( self ) \u00b6 REQUIRED This should install the project in the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def install_project ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the project in the environment. \"\"\" install_project_dev_mode ( self ) \u00b6 REQUIRED This should install the project in the environment such that the environment always reflects the current state of the project. Source code in hatch/env/plugin/interface.py @abstractmethod def install_project_dev_mode ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the project in the environment such that the environment always reflects the current state of the project. \"\"\" join_command_args ( self , args : list [ str ]) \u00b6 This is used by the run command to construct the root command string from the received arguments. Source code in hatch/env/plugin/interface.py def join_command_args ( self , args : list [ str ]): \"\"\" This is used by the [`run`](../cli/reference.md#hatch-run) command to construct the root command string from the received arguments. \"\"\" return self . platform . join_command_args ( args ) remove ( self ) \u00b6 REQUIRED This should perform the necessary steps to completely remove the environment from the system and will only be triggered manually by users with the env remove or env prune commands. Source code in hatch/env/plugin/interface.py @abstractmethod def remove ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should perform the necessary steps to completely remove the environment from the system and will only be triggered manually by users with the [`env remove`](../cli/reference.md#hatch-env-remove) or [`env prune`](../cli/reference.md#hatch-env-prune) commands. \"\"\" resolve_commands ( self , commands : list [ str ]) \u00b6 This expands each command into one or more commands based on any scripts that the user defined. Each expanded command is then finalized by the standard library's os.path.expandvars . Source code in hatch/env/plugin/interface.py def resolve_commands ( self , commands : list [ str ]): \"\"\" This expands each command into one or more commands based on any [scripts](../config/environment.md#scripts) that the user defined. Each expanded command is then finalized by the standard library's [os.path.expandvars](https://docs.python.org/3/library/os.path.html#os.path.expandvars). \"\"\" for command in commands : expanded_commands = self . expand_command ( command ) for expanded_command in expanded_commands : yield expandvars ( expanded_command ) run_shell_commands ( self , commands : list [ str ]) \u00b6 This should yield the standard library's subprocess.CompletedProcess for each command. Additionally, the commands must first be resolved . The command execution should reflect any environment variables the user defined either currently or at the time of creation . For an example, open the default implementation below: Source code in hatch/env/plugin/interface.py def run_shell_commands ( self , commands : list [ str ]): \"\"\" This should yield the standard library's [subprocess.CompletedProcess](https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess) for each command. Additionally, the commands must first be [resolved](environment.md#hatch.env.plugin.interface.EnvironmentInterface.resolve_commands). The command execution should reflect any [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) the user defined either currently or at the time of [creation](environment.md#hatch.env.plugin.interface.EnvironmentInterface.create). For an example, open the default implementation below: \"\"\" with self . set_env_vars (): for command in self . resolve_commands ( commands ): yield self . platform . run_command ( command , shell = True ) set_env_vars ( self ) \u00b6 A convenience context manager that applies the user defined environment variables to the current process. Source code in hatch/env/plugin/interface.py @contextmanager def set_env_vars ( self ): \"\"\" A convenience context manager that applies the user defined [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) to the current process. \"\"\" with EnvVars ( self . env_vars ): yield sync_dependencies ( self ) \u00b6 REQUIRED This should install the dependencies in the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def sync_dependencies ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the [dependencies](environment.md#hatch.env.plugin.interface.EnvironmentInterface.dependencies) in the environment. \"\"\"","title":"Environment"},{"location":"plugins/environment/#environment-plugins","text":"See the documentation for environment configuration .","title":"Environment plugins"},{"location":"plugins/environment/#life-cycle","text":"Whenever an environment is used, the following logic is performed: Source code in hatch/cli/application.py def prepare_environment ( self , environment ): if not environment . exists (): self . display_waiting ( f 'Creating environment: { environment . name } ' ) environment . create () if not environment . skip_install : if environment . pre_install_commands : self . display_waiting ( 'Running pre-installation commands...' ) for process in environment . run_shell_commands ( environment . pre_install_commands ): if process . returncode : self . abort ( f 'Failed with exit code: { process . returncode } ' , code = process . returncode ) if environment . dev_mode : self . display_waiting ( 'Installing project in development mode...' ) environment . install_project_dev_mode () else : self . display_waiting ( 'Installing project...' ) environment . install_project () if environment . post_install_commands : self . display_waiting ( 'Running post-installation commands...' ) for process in environment . run_shell_commands ( environment . post_install_commands ): if process . returncode : self . abort ( f 'Failed with exit code: { process . returncode } ' , code = process . returncode ) if not environment . dependencies_in_sync (): self . display_waiting ( 'Syncing dependencies...' ) environment . sync_dependencies ()","title":"Life cycle"},{"location":"plugins/environment/#built-in","text":"","title":"Built-in"},{"location":"plugins/environment/#virtual","text":"This uses virtual environments backed by the standard virtualenv tool.","title":"Virtual"},{"location":"plugins/environment/#configuration","text":"The environment plugin name is virtual . pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] type = \"virtual\" [envs.<ENV_NAME>] type = \"virtual\"","title":"Configuration"},{"location":"plugins/environment/#extra-options","text":"Option Default Description system-packages false Whether or not to give the virtual environment access to the system site-packages directory python The version of Python to find on your system and subsequently use to create the environment, defaulting to the first python found along your PATH , followed by the Python executable Hatch is running on. For more information, see the documentation .","title":"Extra options"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface","text":"Example usage: plugin.py hooks.py from hatch.env.plugin.interface import EnvironmentInterface class SpecialEnvironment ( EnvironmentInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment","title":"EnvironmentInterface"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.config","text":"pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] [envs.<ENV_NAME>]","title":"config"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.data_directory","text":"The directory reserved exclusively for this plugin as a path-like object.","title":"data_directory"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.dependencies","text":"The list of all project dependencies (if installed and in dev mode ) and environment dependencies .","title":"dependencies"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.dev_mode","text":"pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] dev-mode = ... [envs.<ENV_NAME>] dev-mode = ...","title":"dev_mode"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.env_vars","text":"pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>.env-vars] [envs.<ENV_NAME>.env-vars] Note The environment variable HATCH_ENV_ACTIVE will always be set to the name of the environment.","title":"env_vars"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.name","text":"The name of the environment.","title":"name"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.platform","text":"An instance of Platform .","title":"platform"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.platforms","text":"All names are stored as their lower-cased version. pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] platforms = [...] [envs.<ENV_NAME>] platforms = [...]","title":"platforms"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.root","text":"The root of the project tree as a path-like object.","title":"root"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.skip_install","text":"pyproject.toml hatch.toml [tool.hatch.envs.<ENV_NAME>] skip-install = ... [envs.<ENV_NAME>] skip-install = ...","title":"skip_install"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.activate","text":"A convenience method called when using the environment as a context manager: with environment : ... Source code in hatch/env/plugin/interface.py def activate ( self ): \"\"\" A convenience method called when using the environment as a context manager: ```python with environment: ... ``` \"\"\"","title":"activate()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.apply_features","text":"A convenience method that applies any user defined features to the given requirement. Source code in hatch/env/plugin/interface.py def apply_features ( self , requirement : str ): \"\"\" A convenience method that applies any user defined [features](../config/environment.md#features) to the given requirement. \"\"\" if self . features : features = ',' . join ( self . features ) return f ' { requirement } [ { features } ]' return requirement","title":"apply_features()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.build_environment","text":"This should set up an isolated environment in which to build the project given a set of dependencies and must be a context manager: with environment . build_environment ([ ... ]): ... Source code in hatch/env/plugin/interface.py @contextmanager def build_environment ( self , dependencies : list [ str ]): \"\"\" This should set up an isolated environment in which to [`build`](../cli/reference.md#hatch-build) the project given a set of dependencies and must be a context manager: ```python with environment.build_environment([...]): ... ``` \"\"\" yield","title":"build_environment()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.compatible","text":"Whether or not the environment is compatible with the current user's setup. The default behavior checks for platform compatibility and any method override should keep this check. Source code in hatch/env/plugin/interface.py def compatible ( self ): \"\"\" Whether or not the environment is compatible with the current user's setup. The default behavior checks for [platform compatibility](../config/environment.md#supported-platforms) and any method override should keep this check. \"\"\" if not self . platforms : return True return self . platform . system_name in self . platforms","title":"compatible()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.construct_build_command","text":"This is the canonical way build command options are translated to a subprocess command issued to builders . Source code in hatch/env/plugin/interface.py def construct_build_command ( self , * , directory = None , targets = (), clean = False , hooks_only = False ): \"\"\" This is the canonical way [`build`](../cli/reference.md#hatch-build) command options are translated to a subprocess command issued to [builders](builder.md). \"\"\" command = [ 'python' , '-m' , 'hatchling' , 'build' , '--app' ] if directory : command . extend (( '--directory' , directory )) if targets : for target in targets : command . extend (( '--target' , target )) if clean : command . append ( '--clean' ) if hooks_only : command . append ( '--hooks-only' ) return command","title":"construct_build_command()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.construct_pip_install_command","text":"A convenience method for constructing a pip install command with the given verbosity. The default verbosity is set to one less than Hatch's verbosity. Source code in hatch/env/plugin/interface.py def construct_pip_install_command ( self , args : list [ str ], verbosity = None ): \"\"\" A convenience method for constructing a [`pip install`](https://pip.pypa.io/en/stable/cli/pip_install/) command with the given verbosity. The default verbosity is set to one less than Hatch's verbosity. \"\"\" if verbosity is None : # Default to -1 verbosity verbosity = self . verbosity - 1 command = [ 'python' , '-m' , 'pip' , 'install' , '--disable-pip-version-check' ] if verbosity < 0 : command . append ( f \"- { 'q' * abs ( verbosity ) } \" ) elif verbosity > 0 : command . append ( f \"- { 'v' * abs ( verbosity ) } \" ) command . extend ( args ) return command","title":"construct_pip_install_command()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.create","text":"REQUIRED This should perform the necessary steps to set up the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def create ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should perform the necessary steps to set up the environment. \"\"\"","title":"create()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.deactivate","text":"A convenience method called after using the environment as a context manager: with environment : ... Source code in hatch/env/plugin/interface.py def deactivate ( self ): \"\"\" A convenience method called after using the environment as a context manager: ```python with environment: ... ``` \"\"\"","title":"deactivate()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.dependencies_in_sync","text":"REQUIRED This should indicate whether or not the environment is compatible with the current dependencies . Source code in hatch/env/plugin/interface.py @abstractmethod def dependencies_in_sync ( self ) -> bool : \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should indicate whether or not the environment is compatible with the current [dependencies](environment.md#hatch.env.plugin.interface.EnvironmentInterface.dependencies). \"\"\"","title":"dependencies_in_sync()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.enter_shell","text":"Spawn a shell within the environment. The shell should reflect any environment variables the user defined either currently or at the time of creation . Source code in hatch/env/plugin/interface.py def enter_shell ( self , name , path ): \"\"\" Spawn a [shell](../config/hatch.md#shell) within the environment. The shell should reflect any [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) the user defined either currently or at the time of [creation](environment.md#hatch.env.plugin.interface.EnvironmentInterface.create). \"\"\" with self . set_env_vars (): self . platform . exit_with_command ([ path ])","title":"enter_shell()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.exists","text":"REQUIRED This should indicate whether or not the environment has already been created. Source code in hatch/env/plugin/interface.py @abstractmethod def exists ( self ) -> bool : \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should indicate whether or not the environment has already been created. \"\"\"","title":"exists()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.get_build_process","text":"This will be called when the build environment is active: with environment . build_environment ([ ... ]): build_process = environment . get_build_process ( ... ) This should return the standard library's subprocess.Popen with all output captured by stdout . The command is constructed by passing all keyword arguments to construct_build_command . For an example, open the default implementation below: Source code in hatch/env/plugin/interface.py def get_build_process ( self , ** kwargs ): \"\"\" This will be called when the [build environment](environment.md#hatch.env.plugin.interface.EnvironmentInterface.build_environment) is active: ```python with environment.build_environment([...]): build_process = environment.get_build_process(...) ``` This should return the standard library's [subprocess.Popen](https://docs.python.org/3/library/subprocess.html#subprocess.Popen) with all output captured by `stdout`. The command is constructed by passing all keyword arguments to [construct_build_command](environment.md#hatch.env.plugin.interface.EnvironmentInterface.construct_build_command). For an example, open the default implementation below: \"\"\" return self . platform . capture_process ( self . construct_build_command ( ** kwargs ))","title":"get_build_process()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.install_project","text":"REQUIRED This should install the project in the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def install_project ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the project in the environment. \"\"\"","title":"install_project()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.install_project_dev_mode","text":"REQUIRED This should install the project in the environment such that the environment always reflects the current state of the project. Source code in hatch/env/plugin/interface.py @abstractmethod def install_project_dev_mode ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the project in the environment such that the environment always reflects the current state of the project. \"\"\"","title":"install_project_dev_mode()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.join_command_args","text":"This is used by the run command to construct the root command string from the received arguments. Source code in hatch/env/plugin/interface.py def join_command_args ( self , args : list [ str ]): \"\"\" This is used by the [`run`](../cli/reference.md#hatch-run) command to construct the root command string from the received arguments. \"\"\" return self . platform . join_command_args ( args )","title":"join_command_args()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.remove","text":"REQUIRED This should perform the necessary steps to completely remove the environment from the system and will only be triggered manually by users with the env remove or env prune commands. Source code in hatch/env/plugin/interface.py @abstractmethod def remove ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should perform the necessary steps to completely remove the environment from the system and will only be triggered manually by users with the [`env remove`](../cli/reference.md#hatch-env-remove) or [`env prune`](../cli/reference.md#hatch-env-prune) commands. \"\"\"","title":"remove()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.resolve_commands","text":"This expands each command into one or more commands based on any scripts that the user defined. Each expanded command is then finalized by the standard library's os.path.expandvars . Source code in hatch/env/plugin/interface.py def resolve_commands ( self , commands : list [ str ]): \"\"\" This expands each command into one or more commands based on any [scripts](../config/environment.md#scripts) that the user defined. Each expanded command is then finalized by the standard library's [os.path.expandvars](https://docs.python.org/3/library/os.path.html#os.path.expandvars). \"\"\" for command in commands : expanded_commands = self . expand_command ( command ) for expanded_command in expanded_commands : yield expandvars ( expanded_command )","title":"resolve_commands()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.run_shell_commands","text":"This should yield the standard library's subprocess.CompletedProcess for each command. Additionally, the commands must first be resolved . The command execution should reflect any environment variables the user defined either currently or at the time of creation . For an example, open the default implementation below: Source code in hatch/env/plugin/interface.py def run_shell_commands ( self , commands : list [ str ]): \"\"\" This should yield the standard library's [subprocess.CompletedProcess](https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess) for each command. Additionally, the commands must first be [resolved](environment.md#hatch.env.plugin.interface.EnvironmentInterface.resolve_commands). The command execution should reflect any [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) the user defined either currently or at the time of [creation](environment.md#hatch.env.plugin.interface.EnvironmentInterface.create). For an example, open the default implementation below: \"\"\" with self . set_env_vars (): for command in self . resolve_commands ( commands ): yield self . platform . run_command ( command , shell = True )","title":"run_shell_commands()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.set_env_vars","text":"A convenience context manager that applies the user defined environment variables to the current process. Source code in hatch/env/plugin/interface.py @contextmanager def set_env_vars ( self ): \"\"\" A convenience context manager that applies the user defined [environment variables](environment.md#hatch.env.plugin.interface.EnvironmentInterface.env_vars) to the current process. \"\"\" with EnvVars ( self . env_vars ): yield","title":"set_env_vars()"},{"location":"plugins/environment/#hatch.env.plugin.interface.EnvironmentInterface.sync_dependencies","text":"REQUIRED This should install the dependencies in the environment. Source code in hatch/env/plugin/interface.py @abstractmethod def sync_dependencies ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should install the [dependencies](environment.md#hatch.env.plugin.interface.EnvironmentInterface.dependencies) in the environment. \"\"\"","title":"sync_dependencies()"},{"location":"plugins/metadata-hook/","text":"Metadata hook plugins \u00b6 Metadata hooks allow for the modification of project metadata after it has been loaded. Built-in \u00b6 Custom \u00b6 This is a custom class in a given Python file that inherits from the MetadataHookInterface . Configuration \u00b6 The metadata hook plugin name is custom . pyproject.toml hatch.toml [tool.hatch.metadata.custom] [metadata.custom] An option path is used to specify the path of the Python file, defaulting to build.py . Example \u00b6 build.py from hatchling.metadata.plugin.interface import MetadataHookInterface class CustomMetadataHook ( MetadataHookInterface ): ... If multiple subclasses are found, you must define a function named get_metadata_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom . MetadataHookInterface \u00b6 Example usage: plugin.py hooks.py from hatchling.metadata.plugin.interface import MetadataHookInterface class SpecialMetadataHook ( MetadataHookInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialMetadataHook @hookimpl def hatch_register_metadata_hook (): return SpecialMetadataHook PLUGIN_NAME \u00b6 The name used for selection. config property readonly \u00b6 The hook configuration. pyproject.toml hatch.toml [tool.hatch.metadata.<PLUGIN_NAME>] [metadata.<PLUGIN_NAME>] root property readonly \u00b6 The root of the project tree. update ( self , metadata ) \u00b6 REQUIRED This updates the metadata mapping in-place. Source code in hatchling/metadata/plugin/interface.py def update ( self , metadata ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This updates the metadata mapping in-place. \"\"\" raise NotImplementedError","title":"Metadata hook"},{"location":"plugins/metadata-hook/#metadata-hook-plugins","text":"Metadata hooks allow for the modification of project metadata after it has been loaded.","title":"Metadata hook plugins"},{"location":"plugins/metadata-hook/#built-in","text":"","title":"Built-in"},{"location":"plugins/metadata-hook/#custom","text":"This is a custom class in a given Python file that inherits from the MetadataHookInterface .","title":"Custom"},{"location":"plugins/metadata-hook/#configuration","text":"The metadata hook plugin name is custom . pyproject.toml hatch.toml [tool.hatch.metadata.custom] [metadata.custom] An option path is used to specify the path of the Python file, defaulting to build.py .","title":"Configuration"},{"location":"plugins/metadata-hook/#example","text":"build.py from hatchling.metadata.plugin.interface import MetadataHookInterface class CustomMetadataHook ( MetadataHookInterface ): ... If multiple subclasses are found, you must define a function named get_metadata_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom .","title":"Example"},{"location":"plugins/metadata-hook/#hatchling.metadata.plugin.interface.MetadataHookInterface","text":"Example usage: plugin.py hooks.py from hatchling.metadata.plugin.interface import MetadataHookInterface class SpecialMetadataHook ( MetadataHookInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialMetadataHook @hookimpl def hatch_register_metadata_hook (): return SpecialMetadataHook","title":"MetadataHookInterface"},{"location":"plugins/metadata-hook/#hatchling.metadata.plugin.interface.MetadataHookInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/metadata-hook/#hatchling.metadata.plugin.interface.MetadataHookInterface.config","text":"The hook configuration. pyproject.toml hatch.toml [tool.hatch.metadata.<PLUGIN_NAME>] [metadata.<PLUGIN_NAME>]","title":"config"},{"location":"plugins/metadata-hook/#hatchling.metadata.plugin.interface.MetadataHookInterface.root","text":"The root of the project tree.","title":"root"},{"location":"plugins/metadata-hook/#hatchling.metadata.plugin.interface.MetadataHookInterface.update","text":"REQUIRED This updates the metadata mapping in-place. Source code in hatchling/metadata/plugin/interface.py def update ( self , metadata ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This updates the metadata mapping in-place. \"\"\" raise NotImplementedError","title":"update()"},{"location":"plugins/publisher/","text":"Publisher plugins \u00b6 Built-in \u00b6 PyPI \u00b6 See the documentation for publishing . Configuration \u00b6 The publisher plugin name is pypi . config.toml [publish.pypi] Options \u00b6 Flag Config name Description -u / --user user The user with which to authenticate -a / --auth auth The credentials to use for authentication -r / --repo repo The repository with which to publish artifacts repos A table of named repositories to their respective URLs PublisherInterface ( ABC ) \u00b6 Example usage: plugin.py hooks.py from hatch.publish.plugin.interface import PublisherInterface class SpecialPublisher ( PublisherInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialPublisher @hookimpl def hatch_register_publisher (): return SpecialPublisher PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . cache_dir property readonly \u00b6 The directory reserved exclusively for this plugin as a path-like object. plugin_config : dict property readonly \u00b6 This is defined in Hatch's config file . config.toml [publish.<PLUGIN_NAME>] project_config : dict property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.publish.<PLUGIN_NAME>] [publish.<PLUGIN_NAME>] root property readonly \u00b6 The root of the project tree as a path-like object. publish ( self , artifacts : list [ str ], options : dict ) \u00b6 REQUIRED This is called directly by the publish command with the arguments and options it receives. Source code in hatch/publish/plugin/interface.py @abstractmethod def publish ( self , artifacts : list [ str ], options : dict ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This is called directly by the [`publish`](../cli/reference.md#hatch-publish) command with the arguments and options it receives. \"\"\"","title":"Publisher"},{"location":"plugins/publisher/#publisher-plugins","text":"","title":"Publisher plugins"},{"location":"plugins/publisher/#built-in","text":"","title":"Built-in"},{"location":"plugins/publisher/#pypi","text":"See the documentation for publishing .","title":"PyPI"},{"location":"plugins/publisher/#configuration","text":"The publisher plugin name is pypi . config.toml [publish.pypi]","title":"Configuration"},{"location":"plugins/publisher/#options","text":"Flag Config name Description -u / --user user The user with which to authenticate -a / --auth auth The credentials to use for authentication -r / --repo repo The repository with which to publish artifacts repos A table of named repositories to their respective URLs","title":"Options"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface","text":"Example usage: plugin.py hooks.py from hatch.publish.plugin.interface import PublisherInterface class SpecialPublisher ( PublisherInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialPublisher @hookimpl def hatch_register_publisher (): return SpecialPublisher","title":"PublisherInterface"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.cache_dir","text":"The directory reserved exclusively for this plugin as a path-like object.","title":"cache_dir"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.plugin_config","text":"This is defined in Hatch's config file . config.toml [publish.<PLUGIN_NAME>]","title":"plugin_config"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.project_config","text":"pyproject.toml hatch.toml [tool.hatch.publish.<PLUGIN_NAME>] [publish.<PLUGIN_NAME>]","title":"project_config"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.root","text":"The root of the project tree as a path-like object.","title":"root"},{"location":"plugins/publisher/#hatch.publish.plugin.interface.PublisherInterface.publish","text":"REQUIRED This is called directly by the publish command with the arguments and options it receives. Source code in hatch/publish/plugin/interface.py @abstractmethod def publish ( self , artifacts : list [ str ], options : dict ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This is called directly by the [`publish`](../cli/reference.md#hatch-publish) command with the arguments and options it receives. \"\"\"","title":"publish()"},{"location":"plugins/utilities/","text":"Plugin utilities \u00b6 Application \u00b6 The way output is displayed can be configured by users. abort ( self , message = '' , code = 1 , ** kwargs ) \u00b6 Terminate the program with the given return code. display_debug ( self , message = '' , level = 1 , ** kwargs ) \u00b6 Meant to be used for messages that are not useful for most user experiences. The level option must be between 1 and 3 (inclusive). display_error ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages indicating some unrecoverable error. display_info ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages conveying basic information. display_success ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages indicating some positive outcome. display_waiting ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages shown before potentially time consuming operations. display_warning ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages conveying important information. Platform \u00b6 default_shell property readonly \u00b6 Returns the default shell of the system. On Windows systems the COMSPEC environment variable will be used, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash . linux property readonly \u00b6 Indicates whether Hatch is running on neither Windows nor macOS. macos property readonly \u00b6 Indicates whether Hatch is running on macOS. system_name property readonly \u00b6 One of the following: linux windows macos windows property readonly \u00b6 Indicates whether Hatch is running on Windows. capture_process ( self , command : str | list [ str ], shell = False , ** kwargs ) \u00b6 Equivalent to the standard library's subprocess.Popen , with all output captured by stdout and the command first being properly formatted . check_command ( self , command : str | list [ str ], shell = False , ** kwargs ) \u00b6 Equivalent to run_command , but non-zero exit codes will gracefully end program execution. exit_with_command ( self , command : list [ str ]) \u00b6 Run the given command and exit with its exit code. On non-Windows systems, this uses the standard library's os.execvp . format_for_subprocess ( self , command : str | list [ str ], * , shell : bool ) \u00b6 Format the given command in a cross-platform manner for immediate consumption by subprocess utilities. run_command ( self , command : str | list [ str ], shell = False , ** kwargs ) \u00b6 Equivalent to the standard library's subprocess.run , with the command first being properly formatted .","title":"Utilities"},{"location":"plugins/utilities/#plugin-utilities","text":"","title":"Plugin utilities"},{"location":"plugins/utilities/#hatchling.bridge.app.Application","text":"The way output is displayed can be configured by users.","title":"Application"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.abort","text":"Terminate the program with the given return code.","title":"abort()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_debug","text":"Meant to be used for messages that are not useful for most user experiences. The level option must be between 1 and 3 (inclusive).","title":"display_debug()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_error","text":"Meant to be used for messages indicating some unrecoverable error.","title":"display_error()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_info","text":"Meant to be used for messages conveying basic information.","title":"display_info()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_success","text":"Meant to be used for messages indicating some positive outcome.","title":"display_success()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_waiting","text":"Meant to be used for messages shown before potentially time consuming operations.","title":"display_waiting()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_warning","text":"Meant to be used for messages conveying important information.","title":"display_warning()"},{"location":"plugins/utilities/#hatch.utils.platform.Platform","text":"","title":"Platform"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.default_shell","text":"Returns the default shell of the system. On Windows systems the COMSPEC environment variable will be used, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash .","title":"default_shell"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.linux","text":"Indicates whether Hatch is running on neither Windows nor macOS.","title":"linux"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.macos","text":"Indicates whether Hatch is running on macOS.","title":"macos"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.system_name","text":"One of the following: linux windows macos","title":"system_name"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.windows","text":"Indicates whether Hatch is running on Windows.","title":"windows"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.capture_process","text":"Equivalent to the standard library's subprocess.Popen , with all output captured by stdout and the command first being properly formatted .","title":"capture_process()"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.check_command","text":"Equivalent to run_command , but non-zero exit codes will gracefully end program execution.","title":"check_command()"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.exit_with_command","text":"Run the given command and exit with its exit code. On non-Windows systems, this uses the standard library's os.execvp .","title":"exit_with_command()"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.format_for_subprocess","text":"Format the given command in a cross-platform manner for immediate consumption by subprocess utilities.","title":"format_for_subprocess()"},{"location":"plugins/utilities/#hatch.utils.platform.Platform.run_command","text":"Equivalent to the standard library's subprocess.run , with the command first being properly formatted .","title":"run_command()"},{"location":"plugins/version-scheme/","text":"Version scheme plugins \u00b6 Built-in \u00b6 Standard \u00b6 See the documentation for versioning . Configuration \u00b6 The version scheme plugin name is standard . pyproject.toml hatch.toml [tool.hatch.version] scheme = \"standard\" [version] scheme = \"standard\" VersionSchemeInterface ( ABC ) \u00b6 Example usage: plugin.py hooks.py from hatch.version.scheme.plugin.interface import VersionSchemeInterface class SpecialVersionScheme ( VersionSchemeInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialVersionScheme @hookimpl def hatch_register_version_scheme (): return SpecialVersionScheme PLUGIN_NAME \u00b6 The name used for selection. config : dict property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.version] [version] root property readonly \u00b6 The root of the project tree as a path-like object. update ( self , desired_version : str , original_version : str , version_data : dict ) \u00b6 REQUIRED This should return a normalized form of the desired version and verify that it is higher than the original version. Source code in hatch/version/scheme/plugin/interface.py @abstractmethod def update ( self , desired_version : str , original_version : str , version_data : dict ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should return a normalized form of the desired version and verify that it is higher than the original version. \"\"\"","title":"Version scheme"},{"location":"plugins/version-scheme/#version-scheme-plugins","text":"","title":"Version scheme plugins"},{"location":"plugins/version-scheme/#built-in","text":"","title":"Built-in"},{"location":"plugins/version-scheme/#standard","text":"See the documentation for versioning .","title":"Standard"},{"location":"plugins/version-scheme/#configuration","text":"The version scheme plugin name is standard . pyproject.toml hatch.toml [tool.hatch.version] scheme = \"standard\" [version] scheme = \"standard\"","title":"Configuration"},{"location":"plugins/version-scheme/#hatch.version.scheme.plugin.interface.VersionSchemeInterface","text":"Example usage: plugin.py hooks.py from hatch.version.scheme.plugin.interface import VersionSchemeInterface class SpecialVersionScheme ( VersionSchemeInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialVersionScheme @hookimpl def hatch_register_version_scheme (): return SpecialVersionScheme","title":"VersionSchemeInterface"},{"location":"plugins/version-scheme/#hatch.version.scheme.plugin.interface.VersionSchemeInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/version-scheme/#hatch.version.scheme.plugin.interface.VersionSchemeInterface.config","text":"pyproject.toml hatch.toml [tool.hatch.version] [version]","title":"config"},{"location":"plugins/version-scheme/#hatch.version.scheme.plugin.interface.VersionSchemeInterface.root","text":"The root of the project tree as a path-like object.","title":"root"},{"location":"plugins/version-scheme/#hatch.version.scheme.plugin.interface.VersionSchemeInterface.update","text":"REQUIRED This should return a normalized form of the desired version and verify that it is higher than the original version. Source code in hatch/version/scheme/plugin/interface.py @abstractmethod def update ( self , desired_version : str , original_version : str , version_data : dict ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should return a normalized form of the desired version and verify that it is higher than the original version. \"\"\"","title":"update()"},{"location":"plugins/version-source/","text":"Version source plugins \u00b6 Built-in \u00b6 Regex \u00b6 See the documentation for versioning . Configuration \u00b6 The version source plugin name is regex . pyproject.toml hatch.toml [tool.hatch.version] source = \"regex\" [version] source = \"regex\" Options \u00b6 Option Description path (required) A relative path to a file containing the project's version pattern A regular expression that has a named group called version that represents the version VersionSourceInterface \u00b6 Example usage: plugin.py hooks.py from hatchling.version.source.plugin.interface import VersionSourceInterface class SpecialVersionSource ( VersionSourceInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialVersionSource @hookimpl def hatch_register_version_source (): return SpecialVersionSource PLUGIN_NAME \u00b6 The name used for selection. config property readonly \u00b6 pyproject.toml hatch.toml [tool.hatch.version] [version] root property readonly \u00b6 The root of the project tree as a string. get_version_data ( self ) \u00b6 REQUIRED This should return a mapping with a version key representing the current version of the project and will be displayed when invoking the version command without any arguments. The mapping can contain anything else and will be passed to set_version when updating the version. Source code in hatchling/version/source/plugin/interface.py def get_version_data ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should return a mapping with a `version` key representing the current version of the project and will be displayed when invoking the [`version`](../cli/reference.md#hatch-version) command without any arguments. The mapping can contain anything else and will be passed to [set_version](version-source.md#hatchling.version.source.plugin.interface.VersionSourceInterface.set_version) when updating the version. \"\"\" raise NotImplementedError set_version ( self , version , version_data ) \u00b6 This should update the version to the first argument with the data provided during retrieval. Source code in hatchling/version/source/plugin/interface.py def set_version ( self , version , version_data ): \"\"\" This should update the version to the first argument with the data provided during retrieval. \"\"\" raise NotImplementedError","title":"Version source"},{"location":"plugins/version-source/#version-source-plugins","text":"","title":"Version source plugins"},{"location":"plugins/version-source/#built-in","text":"","title":"Built-in"},{"location":"plugins/version-source/#regex","text":"See the documentation for versioning .","title":"Regex"},{"location":"plugins/version-source/#configuration","text":"The version source plugin name is regex . pyproject.toml hatch.toml [tool.hatch.version] source = \"regex\" [version] source = \"regex\"","title":"Configuration"},{"location":"plugins/version-source/#options","text":"Option Description path (required) A relative path to a file containing the project's version pattern A regular expression that has a named group called version that represents the version","title":"Options"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface","text":"Example usage: plugin.py hooks.py from hatchling.version.source.plugin.interface import VersionSourceInterface class SpecialVersionSource ( VersionSourceInterface ): PLUGIN_NAME = 'special' ... from hatchling.plugin import hookimpl from .plugin import SpecialVersionSource @hookimpl def hatch_register_version_source (): return SpecialVersionSource","title":"VersionSourceInterface"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface.config","text":"pyproject.toml hatch.toml [tool.hatch.version] [version]","title":"config"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface.root","text":"The root of the project tree as a string.","title":"root"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface.get_version_data","text":"REQUIRED This should return a mapping with a version key representing the current version of the project and will be displayed when invoking the version command without any arguments. The mapping can contain anything else and will be passed to set_version when updating the version. Source code in hatchling/version/source/plugin/interface.py def get_version_data ( self ): \"\"\" :material-align-horizontal-left: **REQUIRED** :material-align-horizontal-right: This should return a mapping with a `version` key representing the current version of the project and will be displayed when invoking the [`version`](../cli/reference.md#hatch-version) command without any arguments. The mapping can contain anything else and will be passed to [set_version](version-source.md#hatchling.version.source.plugin.interface.VersionSourceInterface.set_version) when updating the version. \"\"\" raise NotImplementedError","title":"get_version_data()"},{"location":"plugins/version-source/#hatchling.version.source.plugin.interface.VersionSourceInterface.set_version","text":"This should update the version to the first argument with the data provided during retrieval. Source code in hatchling/version/source/plugin/interface.py def set_version ( self , version , version_data ): \"\"\" This should update the version to the first argument with the data provided during retrieval. \"\"\" raise NotImplementedError","title":"set_version()"}]}