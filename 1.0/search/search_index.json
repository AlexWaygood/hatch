{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hatch \u00b6 CI/CD Docs Package Meta Hatch is a modern, extensible Python project manager. Features \u00b6 Standardized build system with reproducible builds by default Robust environment management with support for custom scripts Easy publishing to PyPI or other sources Version management Configurable project generation with sane defaults Responsive CLI, ~2-3x faster than equivalent tools License \u00b6 Hatch is distributed under the terms of any of the following licenses: MIT Apache-2.0 Navigation \u00b6 Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"About"},{"location":"#hatch","text":"CI/CD Docs Package Meta Hatch is a modern, extensible Python project manager.","title":"Hatch"},{"location":"#features","text":"Standardized build system with reproducible builds by default Robust environment management with support for custom scripts Easy publishing to PyPI or other sources Version management Configurable project generation with sane defaults Responsive CLI, ~2-3x faster than equivalent tools","title":"Features"},{"location":"#license","text":"Hatch is distributed under the terms of any of the following licenses: MIT Apache-2.0","title":"License"},{"location":"#navigation","text":"Documentation for specific MAJOR.MINOR versions can be chosen by using the dropdown on the top of every page. The dev version reflects changes that have not yet been released. Also, desktop readers can use special keyboard shortcuts: Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"build/","text":"Builds \u00b6 Configuration \u00b6 Builds are configured using the tool.hatch.build table. Every target is defined by a section within tool.hatch.build.targets , for example: pyproject.toml [tool.hatch.build.targets.wheel] packages = [ \"src/foo\" ] [tool.hatch.build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ] Building \u00b6 Invoking the build command without any arguments will build all defined targets, each in an isolated environment: $ hatch build Setting up build environment... [sdist] dist/hatch_demo-1rc0.tar.gz Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl To only build specific targets, use the -t / --target option: $ hatch build -t wheel Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl If the target supports multiple versions , you can specify the exact versions to build by appending a colon followed by the desired versions separated by commas: $ hatch -v build -t wheel:1 Setting up build environment... ... [wheel] Building `wheel` version `1` dist/hatch_demo-1rc0-py3-none-any.whl Packaging ecosystem \u00b6 Hatch complies with modern Python packaging specs and therefore your projects can be used by other tools with Hatch serving as just the build backend. So you could use tox as an alternative to Hatch's environment management , or cibuildwheel to distribute packages for every platform, and they both will transparently use Hatch without any extra modification.","title":"Builds"},{"location":"build/#builds","text":"","title":"Builds"},{"location":"build/#configuration","text":"Builds are configured using the tool.hatch.build table. Every target is defined by a section within tool.hatch.build.targets , for example: pyproject.toml [tool.hatch.build.targets.wheel] packages = [ \"src/foo\" ] [tool.hatch.build.targets.sdist] exclude = [ \".github/\" , \"docs/\" , ]","title":"Configuration"},{"location":"build/#building","text":"Invoking the build command without any arguments will build all defined targets, each in an isolated environment: $ hatch build Setting up build environment... [sdist] dist/hatch_demo-1rc0.tar.gz Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl To only build specific targets, use the -t / --target option: $ hatch build -t wheel Setting up build environment... [wheel] dist/hatch_demo-1rc0-py3-none-any.whl If the target supports multiple versions , you can specify the exact versions to build by appending a colon followed by the desired versions separated by commas: $ hatch -v build -t wheel:1 Setting up build environment... ... [wheel] Building `wheel` version `1` dist/hatch_demo-1rc0-py3-none-any.whl","title":"Building"},{"location":"build/#packaging-ecosystem","text":"Hatch complies with modern Python packaging specs and therefore your projects can be used by other tools with Hatch serving as just the build backend. So you could use tox as an alternative to Hatch's environment management , or cibuildwheel to distribute packages for every platform, and they both will transparently use Hatch without any extra modification.","title":"Packaging ecosystem"},{"location":"environment/","text":"Environments \u00b6 Environments are designed to allow for isolated workspaces for testing, building documentation, or anything else projects need. Unless an environment is chosen explicitly, Hatch will use the default environment. Creation \u00b6 You can create environments by using the env create command. Let's enter the directory of the project we created in the setup phase : $ hatch env create Creating environment: default Installing project in development mode... Syncing dependencies... Tip You never need to manually create environments as spawning a shell or running commands within one will automatically trigger creation. Entering environments \u00b6 You can spawn a shell within an environment by using the shell command. $ hatch shell (hatch-demo) $ Now confirm the project has been installed: (hatch-demo) $ pip show hatch-demo Name: hatch-demo Version: 0.0.1 ... Finally, see where your environment's Python is located : (hatch-demo) $ python -c \"import sys;print(sys.executable)\" ... You can type exit to leave the environment. Command execution \u00b6 The run command allows you to execute commands in an environment as if you had already entered it. For example, running the following command will output the same path as before: hatch run python -c \"import sys;print(sys.executable)\" Scripts \u00b6 You can also run any scripts that have been defined. You'll notice that in the pyproject.toml file there are already scripts defined in the default environment. Try running the test command, which invokes pytest with some flags for tracking coverage : hatch run test All additional arguments are passed through to scripts, so for example if you wanted to see the version of pytest and which plugins are installed you could do: hatch run test -VV Dependencies \u00b6 Hatch ensures that environments are always compatible with the currently defined project dependencies (if installed and in dev mode ) and environment dependencies . For example, add cowsay as a dependency then try to run it: $ hatch run cowsay \"Hello, world!\" Syncing dependencies... _____________ | Hello, world! | ============= \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Selection \u00b6 You can select which environment to enter or run commands in by using the -e / --env root option or by setting the HATCH_ENV environment variable. The run command allows for more explicit selection by prepending <ENV_NAME>: to commands. For example, if you had the following configuration: pyproject.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" you could then serve your documentation by running: hatch run docs:serve Removal \u00b6 You can remove a single environment by using the env remove command or all of a project's environments by using the env prune command.","title":"Environments"},{"location":"environment/#environments","text":"Environments are designed to allow for isolated workspaces for testing, building documentation, or anything else projects need. Unless an environment is chosen explicitly, Hatch will use the default environment.","title":"Environments"},{"location":"environment/#creation","text":"You can create environments by using the env create command. Let's enter the directory of the project we created in the setup phase : $ hatch env create Creating environment: default Installing project in development mode... Syncing dependencies... Tip You never need to manually create environments as spawning a shell or running commands within one will automatically trigger creation.","title":"Creation"},{"location":"environment/#entering-environments","text":"You can spawn a shell within an environment by using the shell command. $ hatch shell (hatch-demo) $ Now confirm the project has been installed: (hatch-demo) $ pip show hatch-demo Name: hatch-demo Version: 0.0.1 ... Finally, see where your environment's Python is located : (hatch-demo) $ python -c \"import sys;print(sys.executable)\" ... You can type exit to leave the environment.","title":"Entering environments"},{"location":"environment/#command-execution","text":"The run command allows you to execute commands in an environment as if you had already entered it. For example, running the following command will output the same path as before: hatch run python -c \"import sys;print(sys.executable)\"","title":"Command execution"},{"location":"environment/#scripts","text":"You can also run any scripts that have been defined. You'll notice that in the pyproject.toml file there are already scripts defined in the default environment. Try running the test command, which invokes pytest with some flags for tracking coverage : hatch run test All additional arguments are passed through to scripts, so for example if you wanted to see the version of pytest and which plugins are installed you could do: hatch run test -VV","title":"Scripts"},{"location":"environment/#dependencies","text":"Hatch ensures that environments are always compatible with the currently defined project dependencies (if installed and in dev mode ) and environment dependencies . For example, add cowsay as a dependency then try to run it: $ hatch run cowsay \"Hello, world!\" Syncing dependencies... _____________ | Hello, world! | ============= \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||","title":"Dependencies"},{"location":"environment/#selection","text":"You can select which environment to enter or run commands in by using the -e / --env root option or by setting the HATCH_ENV environment variable. The run command allows for more explicit selection by prepending <ENV_NAME>: to commands. For example, if you had the following configuration: pyproject.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.scripts] build = \"mkdocs build --clean --strict\" serve = \"mkdocs serve --dev-addr localhost:8000\" you could then serve your documentation by running: hatch run docs:serve","title":"Selection"},{"location":"environment/#removal","text":"You can remove a single environment by using the env remove command or all of a project's environments by using the env prune command.","title":"Removal"},{"location":"install/","text":"Installation \u00b6 pipx \u00b6 pipx allows for the global installation of Python applications in isolated environments. pipx install hatch pip \u00b6 Hatch is available on PyPI and can be installed with pip . pip install --user hatch Warning This method modifies the Python environment in which you choose to install.","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#pipx","text":"pipx allows for the global installation of Python applications in isolated environments. pipx install hatch","title":"pipx"},{"location":"install/#pip","text":"Hatch is available on PyPI and can be installed with pip . pip install --user hatch Warning This method modifies the Python environment in which you choose to install.","title":"pip"},{"location":"intro/","text":"Introduction \u00b6 Setup \u00b6 Projects can be setup for use by Hatch using the new command. New project \u00b6 Let's say you want to create a project named Hatch Demo . You would run: hatch new \"Hatch Demo\" This would create the following structure in your current working directory: hatch-demo \u251c\u2500\u2500 hatch_demo \u2502 \u251c\u2500\u2500 __about__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 tests \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 LICENSE.txt \u251c\u2500\u2500 README.md \u2514\u2500\u2500 pyproject.toml Tip If you intend for a project to have a command line interface, you can pass the --cli flag. Existing project \u00b6 To initialize an existing project, enter the directory containing the project and run the following: hatch new --init This will interactively guide you through the setup process. Project metadata \u00b6 Next you'll want to define more of your project's metadata located in the pyproject.toml file. You can specify things like its license , the supported versions of Python , and URLs referring to various parts of your project, like documentation. Dependencies \u00b6 The last step of the setup process is to define any dependencies that you'd like your project to begin with.","title":"Introduction"},{"location":"intro/#introduction","text":"","title":"Introduction"},{"location":"intro/#setup","text":"Projects can be setup for use by Hatch using the new command.","title":"Setup"},{"location":"intro/#new-project","text":"Let's say you want to create a project named Hatch Demo . You would run: hatch new \"Hatch Demo\" This would create the following structure in your current working directory: hatch-demo \u251c\u2500\u2500 hatch_demo \u2502 \u251c\u2500\u2500 __about__.py \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 tests \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 LICENSE.txt \u251c\u2500\u2500 README.md \u2514\u2500\u2500 pyproject.toml Tip If you intend for a project to have a command line interface, you can pass the --cli flag.","title":"New project"},{"location":"intro/#existing-project","text":"To initialize an existing project, enter the directory containing the project and run the following: hatch new --init This will interactively guide you through the setup process.","title":"Existing project"},{"location":"intro/#project-metadata","text":"Next you'll want to define more of your project's metadata located in the pyproject.toml file. You can specify things like its license , the supported versions of Python , and URLs referring to various parts of your project, like documentation.","title":"Project metadata"},{"location":"intro/#dependencies","text":"The last step of the setup process is to define any dependencies that you'd like your project to begin with.","title":"Dependencies"},{"location":"next-steps/","text":"Next steps \u00b6 At this point you should have a basic understanding of how to use Hatch. Now you may want to check out advanced configuration for environments or builds , set up your preferred shell , or read more about Hatch's CLI . After that, if you see a need, feel free to write a plugin for extended functionality.","title":"Next steps"},{"location":"next-steps/#next-steps","text":"At this point you should have a basic understanding of how to use Hatch. Now you may want to check out advanced configuration for environments or builds , set up your preferred shell , or read more about Hatch's CLI . After that, if you see a need, feel free to write a plugin for extended functionality.","title":"Next steps"},{"location":"publish/","text":"Publishing \u00b6 After your project is built , you can distribute it using the publish command. The -p / --publisher option controls which publisher to use, with the default being pypi . Artifact selection \u00b6 By default, the dist directory located at the root of your project will be used: $ hatch publish dist/hatch_demo-1rc0-py3-none-any.whl ... success dist/hatch_demo-1rc0.tar.gz ... success [hatch-demo] https://pypi.org/project/hatch-demo/1rc0/ You can instead pass specific paths as arguments: hatch publish /path/to/artifacts foo-1.tar.gz Only files ending with .whl or .tar.gz will be published. Repository \u00b6 You can select the repository (package index) with which to upload using the -r / --repo option or by setting the HATCH_PYPI_REPO environment variable. Rather than specifying the full URL of a repository, you can use a named repository from a publish.pypi.repos table defined in Hatch's config file : config.toml [publish.pypi.repos] repo1 = \"url1\" ... The following repository names are reserved by Hatch and cannot be overriden: Name Repository main https://upload.pypi.org/legacy/ test https://test.pypi.org/legacy/ The main repository is used by default. Authentication \u00b6 The first time you publish to a repository you need to authenticate using the -u / --user (environment variable HATCH_PYPI_USER ) and -a / --auth (environment variable HATCH_PYPI_AUTH ) options. You will be prompted if either option is not provided. The user that most recently published to the chosen repository is cached , with their credentials saved to the system keyring , so that they will no longer need to provide authentication information.","title":"Publishing"},{"location":"publish/#publishing","text":"After your project is built , you can distribute it using the publish command. The -p / --publisher option controls which publisher to use, with the default being pypi .","title":"Publishing"},{"location":"publish/#artifact-selection","text":"By default, the dist directory located at the root of your project will be used: $ hatch publish dist/hatch_demo-1rc0-py3-none-any.whl ... success dist/hatch_demo-1rc0.tar.gz ... success [hatch-demo] https://pypi.org/project/hatch-demo/1rc0/ You can instead pass specific paths as arguments: hatch publish /path/to/artifacts foo-1.tar.gz Only files ending with .whl or .tar.gz will be published.","title":"Artifact selection"},{"location":"publish/#repository","text":"You can select the repository (package index) with which to upload using the -r / --repo option or by setting the HATCH_PYPI_REPO environment variable. Rather than specifying the full URL of a repository, you can use a named repository from a publish.pypi.repos table defined in Hatch's config file : config.toml [publish.pypi.repos] repo1 = \"url1\" ... The following repository names are reserved by Hatch and cannot be overriden: Name Repository main https://upload.pypi.org/legacy/ test https://test.pypi.org/legacy/ The main repository is used by default.","title":"Repository"},{"location":"publish/#authentication","text":"The first time you publish to a repository you need to authenticate using the -u / --user (environment variable HATCH_PYPI_USER ) and -a / --auth (environment variable HATCH_PYPI_AUTH ) options. You will be prompted if either option is not provided. The user that most recently published to the chosen repository is cached , with their credentials saved to the system keyring , so that they will no longer need to provide authentication information.","title":"Authentication"},{"location":"version/","text":"Versioning \u00b6 Configuration \u00b6 When the version is not statically set , configuration is defined in the tool.hatch.version table. The source option determines the source to use for retrieving and updating the version. The regex source is used by default. The regex source requires an option path that represents a relative path to a file containing the project's version: pyproject.toml [tool.hatch.version] path = \"hatch_demo/__about__.py\" The default pattern looks for a variable named __version__ or VERSION that is set to a string containing the version, optionally prefixed with the lowercase letter v . If this doesn't reflect how you store the version, you can define a different regular expression using the pattern option: pyproject.toml [tool.hatch.version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" The pattern must have a named group called version that represents the version. Display \u00b6 Invoking the version command without any arguments will display the current version of the project: $ hatch version 0.0.1 Updating \u00b6 You can update the version like so: $ hatch version \"0.1.0\" Old: 0.0.1 New: 0.1 The scheme option determines the scheme to use for parsing both the existing and new versions. The standard scheme is used by default, which is based on PEP 440 . Rather than setting the version explicitly, you can select the name of a segment used to increment the version: $ hatch version minor Old: 0.1 New: 0.2 You can chain multiple segment updates with a comma. For example, if you wanted to release a preview of your project's first major version, you could do: $ hatch version major,rc Old: 0.2 New: 1rc0 Supported segments \u00b6 Here are the supported segments and how they would influence an existing version of 1 : Segments New version major 2 minor 1.1 micro patch fix 1.0.1 a alpha 1a0 b beta 1b0 c rc pre preview 1rc0 r rev post 1.post0 dev 1.dev0","title":"Versioning"},{"location":"version/#versioning","text":"","title":"Versioning"},{"location":"version/#configuration","text":"When the version is not statically set , configuration is defined in the tool.hatch.version table. The source option determines the source to use for retrieving and updating the version. The regex source is used by default. The regex source requires an option path that represents a relative path to a file containing the project's version: pyproject.toml [tool.hatch.version] path = \"hatch_demo/__about__.py\" The default pattern looks for a variable named __version__ or VERSION that is set to a string containing the version, optionally prefixed with the lowercase letter v . If this doesn't reflect how you store the version, you can define a different regular expression using the pattern option: pyproject.toml [tool.hatch.version] path = \"pkg/__init__.py\" pattern = \"BUILD = 'b(?P<version>)'\" The pattern must have a named group called version that represents the version.","title":"Configuration"},{"location":"version/#display","text":"Invoking the version command without any arguments will display the current version of the project: $ hatch version 0.0.1","title":"Display"},{"location":"version/#updating","text":"You can update the version like so: $ hatch version \"0.1.0\" Old: 0.0.1 New: 0.1 The scheme option determines the scheme to use for parsing both the existing and new versions. The standard scheme is used by default, which is based on PEP 440 . Rather than setting the version explicitly, you can select the name of a segment used to increment the version: $ hatch version minor Old: 0.1 New: 0.2 You can chain multiple segment updates with a comma. For example, if you wanted to release a preview of your project's first major version, you could do: $ hatch version major,rc Old: 0.2 New: 1rc0","title":"Updating"},{"location":"version/#supported-segments","text":"Here are the supported segments and how they would influence an existing version of 1 : Segments New version major 2 minor 1.1 micro patch fix 1.0.1 a alpha 1a0 b beta 1b0 c rc pre preview 1rc0 r rev post 1.post0 dev 1.dev0","title":"Supported segments"},{"location":"cli/about/","text":"About \u00b6 Verbosity \u00b6 The amount of displayed output is controlled solely by the -v / --verbose (environment variable HATCH_VERBOSE ) and -q / --quiet (environment variable HATCH_QUIET ) root options . The levels are documented here . Project awareness \u00b6 No matter the mode , Hatch will always change to the project's root directory for entering or running commands in environments. Tab completion \u00b6 Completion is achieved by saving a script and then executing it as a part of your shell's startup sequence. Afterward, you'll need to start a new shell in order for the changes to take effect. Bash Z shell fish Save the script somewhere: _HATCH_COMPLETE=bash_source hatch > ~/.hatch-complete.bash Source the file in ~/.bashrc (or ~/.bash_profile if on macOS): . ~/.hatch-complete.bash Save the script somewhere: _HATCH_COMPLETE=zsh_source hatch > ~/.hatch-complete.zsh Source the file in ~/.zshrc : . ~/.hatch-complete.zsh Save the script in ~/.config/fish/completions : _HATCH_COMPLETE=fish_source hatch > ~/.config/fish/completions/hatch.fish","title":"About"},{"location":"cli/about/#about","text":"","title":"About"},{"location":"cli/about/#verbosity","text":"The amount of displayed output is controlled solely by the -v / --verbose (environment variable HATCH_VERBOSE ) and -q / --quiet (environment variable HATCH_QUIET ) root options . The levels are documented here .","title":"Verbosity"},{"location":"cli/about/#project-awareness","text":"No matter the mode , Hatch will always change to the project's root directory for entering or running commands in environments.","title":"Project awareness"},{"location":"cli/about/#tab-completion","text":"Completion is achieved by saving a script and then executing it as a part of your shell's startup sequence. Afterward, you'll need to start a new shell in order for the changes to take effect. Bash Z shell fish Save the script somewhere: _HATCH_COMPLETE=bash_source hatch > ~/.hatch-complete.bash Source the file in ~/.bashrc (or ~/.bash_profile if on macOS): . ~/.hatch-complete.bash Save the script somewhere: _HATCH_COMPLETE=zsh_source hatch > ~/.hatch-complete.zsh Source the file in ~/.zshrc : . ~/.hatch-complete.zsh Save the script in ~/.config/fish/completions : _HATCH_COMPLETE=fish_source hatch > ~/.config/fish/completions/hatch.fish","title":"Tab completion"},{"location":"cli/reference/","text":"hatch \u00b6 Usage: hatch [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --env , -e text The name of the environment to use [env var: HATCH_ENV ] default --project , -p text The name of the project to work on [env var: HATCH_PROJECT ] None --color / --no-color boolean Whether or not to display colored output (default is auto-detection) [env var: HATCH_COLOR ] None --verbose , -v integer range ( 0 and above) Increase verbosity (can be used additively) [env var: HATCH_VERBOSE ] 0 --quiet , -q integer range ( 0 and above) Decrease verbosity (can be used additively) [env var: HATCH_QUIET ] 0 --data-dir text The path to a custom directory used to persist data [env var: HATCH_DATA_DIR ] None --cache-dir text The path to a custom directory used to cache data [env var: HATCH_CACHE_DIR ] None --config text The path to a custom config file to use [env var: HATCH_CONFIG ] None --version boolean Show the version and exit. False --help boolean Show this message and exit. False hatch build \u00b6 Build a project. Usage: hatch build [OPTIONS] [LOCATION] Options: Name Type Description Default --target , -t text The target to build, overriding project defaults. This may be selected multiple times e.g. -t sdist -t wheel None --clean , -c boolean Whether or not each build target should first remove any of its existing artifacts False --ext boolean Whether or not to only execute build hooks for distributing binary Python packages, such as compiling extensions. Equivalent to --hooks-only -t wheel False --hooks-only boolean Whether or not to only execute build hooks False --help boolean Show this message and exit. False hatch config \u00b6 Manage the config file Usage: hatch config [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False hatch config explore \u00b6 Open the config location in your file manager. Usage: hatch config explore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config find \u00b6 Show the location of the config file. Usage: hatch config find [OPTIONS] Options: Name Type Description Default --copy , -c boolean Copy the path to the config file to the clipboard False --help boolean Show this message and exit. False hatch config restore \u00b6 Restore the config file to default settings. Usage: hatch config restore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config set \u00b6 Assign values to config file entries. If the value is omitted, you will be prompted, with the input hidden if it is sensitive. Usage: hatch config set [OPTIONS] KEY [VALUE] Options: Name Type Description Default --help boolean Show this message and exit. False hatch config show \u00b6 Show the contents of the config file. Usage: hatch config show [OPTIONS] Options: Name Type Description Default --all , -a boolean No not scrub secret fields False --help boolean Show this message and exit. False hatch config update \u00b6 Update the config file with any new fields. Usage: hatch config update [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env \u00b6 Manage project environments Usage: hatch env [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False hatch env create \u00b6 Create an environment. Usage: hatch env create [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env prune \u00b6 Remove all environments. Usage: hatch env prune [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch env remove \u00b6 Remove an environment. Usage: hatch env remove [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False hatch new \u00b6 Create or initialize a project. Usage: hatch new [OPTIONS] [NAME] [LOCATION] Options: Name Type Description Default -i boolean Interactively choose details about the project False --cli boolean Give the project a command line interface False --init boolean Initialize an existing project False --help boolean Show this message and exit. False hatch publish \u00b6 Publish build artifacts. Usage: hatch publish [OPTIONS] [ARTIFACTS]... Options: Name Type Description Default --user , -u text The user with which to authenticate [env var: HATCH_PYPI_USER ] None --auth , -a text The credentials to use for authentication [env var: HATCH_PYPI_AUTH ] None --repo , -r text The repository with which to publish artifacts [env var: HATCH_PYPI_REPO ] None --no-prompt , -n boolean Do not prompt for missing required fields False --publisher , -p text The publisher plugin to use (default is pypi ) [env var: HATCH_PUBLISHER ] pypi --option , -o text Options to pass to the publisher plugin. This may be selected multiple times e.g. -o foo=bar -o baz=23 [env var: HATCH_PUBLISHER_OPTIONS ] None --help boolean Show this message and exit. False hatch run \u00b6 Run commands within a project's environment. Usage: hatch run [OPTIONS] ARGS... Options: Name Type Description Default --help boolean Show this message and exit. False hatch shell \u00b6 Enter a shell within a project's environment. Usage: hatch shell [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch status \u00b6 Show information about the current environment. Usage: hatch status [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False hatch version \u00b6 View or set a project's version. Usage: hatch version [OPTIONS] [DESIRED_VERSION] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"Reference"},{"location":"cli/reference/#hatch","text":"Usage: hatch [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --env , -e text The name of the environment to use [env var: HATCH_ENV ] default --project , -p text The name of the project to work on [env var: HATCH_PROJECT ] None --color / --no-color boolean Whether or not to display colored output (default is auto-detection) [env var: HATCH_COLOR ] None --verbose , -v integer range ( 0 and above) Increase verbosity (can be used additively) [env var: HATCH_VERBOSE ] 0 --quiet , -q integer range ( 0 and above) Decrease verbosity (can be used additively) [env var: HATCH_QUIET ] 0 --data-dir text The path to a custom directory used to persist data [env var: HATCH_DATA_DIR ] None --cache-dir text The path to a custom directory used to cache data [env var: HATCH_CACHE_DIR ] None --config text The path to a custom config file to use [env var: HATCH_CONFIG ] None --version boolean Show the version and exit. False --help boolean Show this message and exit. False","title":"hatch"},{"location":"cli/reference/#hatch-build","text":"Build a project. Usage: hatch build [OPTIONS] [LOCATION] Options: Name Type Description Default --target , -t text The target to build, overriding project defaults. This may be selected multiple times e.g. -t sdist -t wheel None --clean , -c boolean Whether or not each build target should first remove any of its existing artifacts False --ext boolean Whether or not to only execute build hooks for distributing binary Python packages, such as compiling extensions. Equivalent to --hooks-only -t wheel False --hooks-only boolean Whether or not to only execute build hooks False --help boolean Show this message and exit. False","title":"build"},{"location":"cli/reference/#hatch-config","text":"Manage the config file Usage: hatch config [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"config"},{"location":"cli/reference/#hatch-config-explore","text":"Open the config location in your file manager. Usage: hatch config explore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"explore"},{"location":"cli/reference/#hatch-config-find","text":"Show the location of the config file. Usage: hatch config find [OPTIONS] Options: Name Type Description Default --copy , -c boolean Copy the path to the config file to the clipboard False --help boolean Show this message and exit. False","title":"find"},{"location":"cli/reference/#hatch-config-restore","text":"Restore the config file to default settings. Usage: hatch config restore [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"restore"},{"location":"cli/reference/#hatch-config-set","text":"Assign values to config file entries. If the value is omitted, you will be prompted, with the input hidden if it is sensitive. Usage: hatch config set [OPTIONS] KEY [VALUE] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"set"},{"location":"cli/reference/#hatch-config-show","text":"Show the contents of the config file. Usage: hatch config show [OPTIONS] Options: Name Type Description Default --all , -a boolean No not scrub secret fields False --help boolean Show this message and exit. False","title":"show"},{"location":"cli/reference/#hatch-config-update","text":"Update the config file with any new fields. Usage: hatch config update [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"update"},{"location":"cli/reference/#hatch-env","text":"Manage project environments Usage: hatch env [OPTIONS] COMMAND [ARGS]... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"env"},{"location":"cli/reference/#hatch-env-create","text":"Create an environment. Usage: hatch env create [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"create"},{"location":"cli/reference/#hatch-env-prune","text":"Remove all environments. Usage: hatch env prune [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"prune"},{"location":"cli/reference/#hatch-env-remove","text":"Remove an environment. Usage: hatch env remove [OPTIONS] [ENV_NAME] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"remove"},{"location":"cli/reference/#hatch-new","text":"Create or initialize a project. Usage: hatch new [OPTIONS] [NAME] [LOCATION] Options: Name Type Description Default -i boolean Interactively choose details about the project False --cli boolean Give the project a command line interface False --init boolean Initialize an existing project False --help boolean Show this message and exit. False","title":"new"},{"location":"cli/reference/#hatch-publish","text":"Publish build artifacts. Usage: hatch publish [OPTIONS] [ARTIFACTS]... Options: Name Type Description Default --user , -u text The user with which to authenticate [env var: HATCH_PYPI_USER ] None --auth , -a text The credentials to use for authentication [env var: HATCH_PYPI_AUTH ] None --repo , -r text The repository with which to publish artifacts [env var: HATCH_PYPI_REPO ] None --no-prompt , -n boolean Do not prompt for missing required fields False --publisher , -p text The publisher plugin to use (default is pypi ) [env var: HATCH_PUBLISHER ] pypi --option , -o text Options to pass to the publisher plugin. This may be selected multiple times e.g. -o foo=bar -o baz=23 [env var: HATCH_PUBLISHER_OPTIONS ] None --help boolean Show this message and exit. False","title":"publish"},{"location":"cli/reference/#hatch-run","text":"Run commands within a project's environment. Usage: hatch run [OPTIONS] ARGS... Options: Name Type Description Default --help boolean Show this message and exit. False","title":"run"},{"location":"cli/reference/#hatch-shell","text":"Enter a shell within a project's environment. Usage: hatch shell [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"shell"},{"location":"cli/reference/#hatch-status","text":"Show information about the current environment. Usage: hatch status [OPTIONS] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"status"},{"location":"cli/reference/#hatch-version","text":"View or set a project's version. Usage: hatch version [OPTIONS] [DESIRED_VERSION] Options: Name Type Description Default --help boolean Show this message and exit. False","title":"version"},{"location":"config/build/","text":"Build configuration \u00b6 All build configuration is defined in the tool.hatch.build table. Build targets are defined as sections within tool.hatch.build.targets : pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>] For each build target you may override any of the defaults set in the top-level tool.hatch.build table. Build system \u00b6 To be compatible with the broader Python packaging ecosystem , you must define the build system as follows: pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" The version of hatchling defined here will be used to build all targets. Hatchling is a PEP 517 / PEP 660 compatible build system and is a dependency of Hatch itself. File selection \u00b6 VCS \u00b6 By default, Hatch will respect any .gitignore file located at your project's root. Set ignore-vcs to true to disable this behavior: pyproject.toml [tool.hatch.build] ignore-vcs = true Patterns \u00b6 You can set the include and exclude options to select exactly which files will be shipped in each build, with exclude taking precedence. The options may be defined as either an array of strings or a comma-separated string, with every entry representing a Git-style glob pattern . For example, the following configuration: pyproject.toml [tool.hatch.build] include = [ \"pkg/*.py\" , \"tests/\" , ] exclude = \"*.json,pkg/_compat.py\" will exclude every file with a .json extension, and will include everything under a tests directory located at the root and every file with a .py extension that is directly under a pkg directory located at the root except for _compat.py . Packages \u00b6 The packages option can be used to include specific Python packages. This option is semantically equivalent to include except that every entry is a simple relative path and the shipped path will be collapsed to only include the final component. So for example, if you want to ship a package foo that is stored in a directory src you would do: pyproject.toml [tool.hatch.build] packages = \"src/foo\" Artifacts \u00b6 If you want to include files that are ignored by your VCS , such as those that might be created by build hooks , you can use the artifacts option. This option is semantically equivalent to include . pyproject.toml [tool.hatch.build] artifacts = [ \"*.so\" , \"*.dll\" , ] Default file selection \u00b6 If no file selection options are provided, then what gets included is determined by each build target . Reproducible builds \u00b6 By default, build targets will build in a reproducible manner provided that they support that behavior. To disable this, set reproducible to false : pyproject.toml [tool.hatch.build] reproducible = false Output directory \u00b6 When the output directory is not provided to the build command, the dist directory will be used by default. You can change the default to a different directory using a relative or absolute path like so: pyproject.toml [tool.hatch.build] directory = \"<PATH>\" Dev mode \u00b6 In most cases, dev mode environment installations or editable installs in general will work as expected. However, for some project layouts you need to explicitly define which directories to add to Python's search path, such as for namespace packages . You can do this with the dev-mode-dirs option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.build] dev-mode-dirs = \".\" Build targets \u00b6 A build target can be provided by any builder plugin . There are three built-in build targets: wheel , sdist , and custom . Dependencies \u00b6 You can specify additional dependencies that will be installed in each build environment, such as for third party builders: pyproject.toml [tool.hatch.build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ] Versions \u00b6 If a build target supports multiple build strategies or if there are major changes over time, you can specify exactly which versions you want to build using the versions option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ] Build hooks \u00b6 A build hook defines code that will be executed at various stages of the build process and can be provided by any build hook plugin . There is one built-in build hook: custom . Build hooks can be applied either globally: pyproject.toml [tool.hatch.build.hooks.<HOOK_NAME>] or to specific build targets: pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>] Dependencies \u00b6 You can specify additional dependencies that will be installed in each build environment, such as for third party build hooks: pyproject.toml [tool.hatch.build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ] Order of execution \u00b6 For each build target, build hooks execute in the order in which they are defined, starting with target-specific hooks. As an example, for the following configuration: pyproject.toml [tool.hatch.build.hooks.hook3] [tool.hatch.build.hooks.hook1] [tool.hatch.build.targets.foo.hooks.hook2] When target foo is built, build hook hook2 will be executed first, followed by hook3 , and then finally hook1 .","title":"Build"},{"location":"config/build/#build-configuration","text":"All build configuration is defined in the tool.hatch.build table. Build targets are defined as sections within tool.hatch.build.targets : pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>] For each build target you may override any of the defaults set in the top-level tool.hatch.build table.","title":"Build configuration"},{"location":"config/build/#build-system","text":"To be compatible with the broader Python packaging ecosystem , you must define the build system as follows: pyproject.toml [build-system] requires = [ \"hatchling\" ] build-backend = \"hatchling.build\" The version of hatchling defined here will be used to build all targets. Hatchling is a PEP 517 / PEP 660 compatible build system and is a dependency of Hatch itself.","title":"Build system"},{"location":"config/build/#file-selection","text":"","title":"File selection"},{"location":"config/build/#vcs","text":"By default, Hatch will respect any .gitignore file located at your project's root. Set ignore-vcs to true to disable this behavior: pyproject.toml [tool.hatch.build] ignore-vcs = true","title":"VCS"},{"location":"config/build/#patterns","text":"You can set the include and exclude options to select exactly which files will be shipped in each build, with exclude taking precedence. The options may be defined as either an array of strings or a comma-separated string, with every entry representing a Git-style glob pattern . For example, the following configuration: pyproject.toml [tool.hatch.build] include = [ \"pkg/*.py\" , \"tests/\" , ] exclude = \"*.json,pkg/_compat.py\" will exclude every file with a .json extension, and will include everything under a tests directory located at the root and every file with a .py extension that is directly under a pkg directory located at the root except for _compat.py .","title":"Patterns"},{"location":"config/build/#packages","text":"The packages option can be used to include specific Python packages. This option is semantically equivalent to include except that every entry is a simple relative path and the shipped path will be collapsed to only include the final component. So for example, if you want to ship a package foo that is stored in a directory src you would do: pyproject.toml [tool.hatch.build] packages = \"src/foo\"","title":"Packages"},{"location":"config/build/#artifacts","text":"If you want to include files that are ignored by your VCS , such as those that might be created by build hooks , you can use the artifacts option. This option is semantically equivalent to include . pyproject.toml [tool.hatch.build] artifacts = [ \"*.so\" , \"*.dll\" , ]","title":"Artifacts"},{"location":"config/build/#default-file-selection","text":"If no file selection options are provided, then what gets included is determined by each build target .","title":"Default file selection"},{"location":"config/build/#reproducible-builds","text":"By default, build targets will build in a reproducible manner provided that they support that behavior. To disable this, set reproducible to false : pyproject.toml [tool.hatch.build] reproducible = false","title":"Reproducible builds"},{"location":"config/build/#output-directory","text":"When the output directory is not provided to the build command, the dist directory will be used by default. You can change the default to a different directory using a relative or absolute path like so: pyproject.toml [tool.hatch.build] directory = \"<PATH>\"","title":"Output directory"},{"location":"config/build/#dev-mode","text":"In most cases, dev mode environment installations or editable installs in general will work as expected. However, for some project layouts you need to explicitly define which directories to add to Python's search path, such as for namespace packages . You can do this with the dev-mode-dirs option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.build] dev-mode-dirs = \".\"","title":"Dev mode"},{"location":"config/build/#build-targets","text":"A build target can be provided by any builder plugin . There are three built-in build targets: wheel , sdist , and custom .","title":"Build targets"},{"location":"config/build/#dependencies","text":"You can specify additional dependencies that will be installed in each build environment, such as for third party builders: pyproject.toml [tool.hatch.build.targets.your-target-name] dependencies = [ \"your-builder-plugin\" ]","title":"Dependencies"},{"location":"config/build/#versions","text":"If a build target supports multiple build strategies or if there are major changes over time, you can specify exactly which versions you want to build using the versions option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>] versions = [ \"v1\" , \"beta-feature\" , ]","title":"Versions"},{"location":"config/build/#build-hooks","text":"A build hook defines code that will be executed at various stages of the build process and can be provided by any build hook plugin . There is one built-in build hook: custom . Build hooks can be applied either globally: pyproject.toml [tool.hatch.build.hooks.<HOOK_NAME>] or to specific build targets: pyproject.toml [tool.hatch.build.targets.<TARGET_NAME>.hooks.<HOOK_NAME>]","title":"Build hooks"},{"location":"config/build/#dependencies_1","text":"You can specify additional dependencies that will be installed in each build environment, such as for third party build hooks: pyproject.toml [tool.hatch.build.hooks.your-hook-name] dependencies = [ \"your-build-hook-plugin\" ]","title":"Dependencies"},{"location":"config/build/#order-of-execution","text":"For each build target, build hooks execute in the order in which they are defined, starting with target-specific hooks. As an example, for the following configuration: pyproject.toml [tool.hatch.build.hooks.hook3] [tool.hatch.build.hooks.hook1] [tool.hatch.build.targets.foo.hooks.hook2] When target foo is built, build hook hook2 will be executed first, followed by hook3 , and then finally hook1 .","title":"Order of execution"},{"location":"config/dependency/","text":"Dependency configuration \u00b6 :root { font-variant-ligatures: none; } Project dependencies are defined with PEP 508 strings using optional PEP 440 version specifiers . Version specifiers \u00b6 A version specifier consists of a series of version clauses, separated by commas. For example: pyproject.toml [project] ... dependencies = [ \"cryptography\" , \"click>=7, <9, != 8.0.0\" , \"python-dateutil==2.8.*\" , \"numpy~=1.21.4\" , ] The comma is equivalent to a logical AND operator: a candidate version must match all given version clauses in order to match the specifier as a whole. Operators \u00b6 Operators Function ~= Compatible release == Version matching != Version exclusion <= , >= Inclusive ordered comparison < , > Exclusive ordered comparison === Arbitrary equality Version matching \u00b6 A version matching clause includes the version matching operator == and a version identifier. By default, the version matching operator is based on a strict equality comparison: the specified version must be exactly the same as the requested version. Clause Allowed versions ==1 1.0.0 ==1.2 1.2.0 Prefix matching may be requested instead of strict comparison, by appending a trailing .* to the version identifier in the version matching clause. This means that additional trailing segments will be ignored when determining whether or not a version identifier matches the clause. Clause Allowed versions ==1.* >=1.0.0, <2.0.0 ==1.2.* >=1.2.0, <1.3.0 Compatible release \u00b6 A compatible release clause consists of the compatible release operator ~= and a version identifier. It matches any candidate version that is expected to be compatible with the specified version. For a given release identifier V.N , the compatible release clause is approximately equivalent to the following pair of comparison clauses: >= V.N, == V.* This operator cannot be used with a single segment version number such as ~=1 . Clause Allowed versions ~=1.2 >=1.2.0, <2.0.0 ~=1.2.3 >=1.2.3, <1.3.0 Version exclusion \u00b6 A version exclusion clause includes the version exclusion operator != and a version identifier. The allowed version identifiers and comparison semantics are the same as those of the Version matching operator, except that the sense of any match is inverted. Ordered comparison \u00b6 Inclusive comparisons allow for the version identifier part of clauses whereas exclusive comparisons do not. For example, >=1.2 allows for version 1.2.0 while >1.2 does not. Unlike the inclusive ordered comparisons <= and >= , the exclusive ordered comparisons < and > specifically exclude pre-releases, post-releases, and local versions of the specified version. Arbitrary equality \u00b6 Though heavily discouraged, arbitrary equality comparisons allow for simple string matching without any version semantics, for example ===foobar . Environment markers \u00b6 Environment markers allow for dependencies to only be installed when certain conditions are met. For example, if you need to install the latest version of cryptography that is available for a given Python major version you could define the following: cryptography==3.3.2; python_version < \"3\" cryptography>=35.0; python_version > \"3\" Alternatively, if you only need it on Python 3 when running on Windows you could do: cryptography; python_version ~= \"3.0\" and platform_system == \"Windows\" The available environment markers are as follows. Marker Python equivalent Examples os_name import os os.name posix java sys_platform import sys sys.platform linux win32 darwin platform_machine import platform platform.machine() x86_64 platform_python_implementation import platform platform.python_implementation() CPython Jython platform_release import platform platform.release() 1.8.0_51 3.14.1-x86_64-linode39 platform_system import platform platform.system() Linux Windows Darwin platform_version import platform platform.version() 10.0.19041 #1 SMP Fri Apr 2 22:23:49 UTC 2021 python_version import platform '.'.join(platform.python_version_tuple()[:2]) 2.7 3.10 python_full_version import platform platform.python_version() 2.7.18 3.11.0b1 implementation_name import sys sys.implementation.name cpython implementation_version See here 2.7.18 3.11.0b1 Features \u00b6 You can select groups of optional dependencies to install using the extras syntax. For example, if a dependency named foo defined the following: pyproject.toml [project.optional-dependencies] crypto = [ \"PyJWT\" , \"cryptography\" , ] fastjson = [ \"orjson\" , ] cli = [ \"prompt-toolkit\" , \"colorama; platform_system == 'Windows'\" , ] You can select the cli and crypto features like so: foo[cli,crypto]==1.* Note that the features come immediately after the package name, before any version specifiers . Direct references \u00b6 Instead of using normal version specifiers and fetching packages from an index like PyPI , you can define exact sources using direct references with an explicit URI . Direct references are not meant to be used for dependencies of a published project but rather are used for defining dependencies for an environment . Version control systems \u00b6 Various version control systems (VCS) are supported as long as the associated executable is available along your PATH. VCS direct references are defined using one of the following formats: <SCHEME>://<PATH> <SCHEME>://<PATH>@<REVISION> You may also append a #subdirectory=<PATH> component for specifying the relative path to the Python package when it is not located at the root e.g. #subdirectory=lib/foo . For more information, refer to this . Supported VCS \u00b6 Git Mercurial Subversion Bazaar Executable Schemes Revisions Example git git+file git+https git+ssh git+http git+git git Commit hash Tag name Branch name git+https://github.com/org/proj.git@v1 Executable Schemes Revisions Example hg hg+file hg+https hg+ssh hg+http hg+static-http Revision hash Revision number Tag name Branch name hg+file:///path/to/proj@v1 Executable Schemes Revisions Example svn svn+https svn+ssh svn+http svn+svn svn Revision number svn+file:///path/to/proj Executable Schemes Revisions Example bzr bzr+https bzr+ssh bzr+sftp bzr+lp bzr+http bzr+ftp Revision number Tag name bzr+lp:proj@v1 Local \u00b6 You can install local packages with the file scheme in the following format: file://<HOST>/<PATH> The <HOST> is only used on Windows systems, where it can refer to a network share. If omitted it is assumed to be localhost and the third slash must still be present. The <PATH> can refer to a source archive, a wheel, or a directory containing a Python package. Type Unix Windows Source archive file:///path/to/pkg.tar.gz file:///c:/path/to/pkg.tar.gz Wheel file:///path/to/pkg.whl file:///c:/path/to/pkg.whl Directory file:///path/to/pkg file:///c:/path/to/pkg You may also specify paths relative to your project's root directory on all platforms by omitting the leading slashes and beginning the path with a dot: file:./pkg_inside_project file:../pkg_alongside_project Remote \u00b6 You can install source archives and wheels by simply referring to a URL: https://github.com/psf/black/archive/refs/tags/21.10b0.zip https://download.pytorch.org/whl/cu102/torch-1.10.0%2Bcu102-cp39-cp39-linux_x86_64.whl An expected hash value may be specified by appending a #<HASH_ALGORITHM>=<EXPECTED_HASH> component: https://github.com/psf/requests/archive/refs/tags/v2.26.0.zip#sha256=eb729a757f01c10546ebd179ae2aec852dd0d7f8ada2328ccf4558909d859985 If the hash differs from the expected hash, the installation will fail. It is recommended that only hashes which are unconditionally provided by the latest version of the standard library's hashlib module be used for hashes. As of Python 3.10, that list consists of: md5 sha1 sha224 sha256 sha384 sha512 blake2b blake2s","title":"Dependencies"},{"location":"config/dependency/#dependency-configuration","text":":root { font-variant-ligatures: none; } Project dependencies are defined with PEP 508 strings using optional PEP 440 version specifiers .","title":"Dependency configuration"},{"location":"config/dependency/#version-specifiers","text":"A version specifier consists of a series of version clauses, separated by commas. For example: pyproject.toml [project] ... dependencies = [ \"cryptography\" , \"click>=7, <9, != 8.0.0\" , \"python-dateutil==2.8.*\" , \"numpy~=1.21.4\" , ] The comma is equivalent to a logical AND operator: a candidate version must match all given version clauses in order to match the specifier as a whole.","title":"Version specifiers"},{"location":"config/dependency/#operators","text":"Operators Function ~= Compatible release == Version matching != Version exclusion <= , >= Inclusive ordered comparison < , > Exclusive ordered comparison === Arbitrary equality","title":"Operators"},{"location":"config/dependency/#version-matching","text":"A version matching clause includes the version matching operator == and a version identifier. By default, the version matching operator is based on a strict equality comparison: the specified version must be exactly the same as the requested version. Clause Allowed versions ==1 1.0.0 ==1.2 1.2.0 Prefix matching may be requested instead of strict comparison, by appending a trailing .* to the version identifier in the version matching clause. This means that additional trailing segments will be ignored when determining whether or not a version identifier matches the clause. Clause Allowed versions ==1.* >=1.0.0, <2.0.0 ==1.2.* >=1.2.0, <1.3.0","title":"Version matching"},{"location":"config/dependency/#compatible-release","text":"A compatible release clause consists of the compatible release operator ~= and a version identifier. It matches any candidate version that is expected to be compatible with the specified version. For a given release identifier V.N , the compatible release clause is approximately equivalent to the following pair of comparison clauses: >= V.N, == V.* This operator cannot be used with a single segment version number such as ~=1 . Clause Allowed versions ~=1.2 >=1.2.0, <2.0.0 ~=1.2.3 >=1.2.3, <1.3.0","title":"Compatible release"},{"location":"config/dependency/#version-exclusion","text":"A version exclusion clause includes the version exclusion operator != and a version identifier. The allowed version identifiers and comparison semantics are the same as those of the Version matching operator, except that the sense of any match is inverted.","title":"Version exclusion"},{"location":"config/dependency/#ordered-comparison","text":"Inclusive comparisons allow for the version identifier part of clauses whereas exclusive comparisons do not. For example, >=1.2 allows for version 1.2.0 while >1.2 does not. Unlike the inclusive ordered comparisons <= and >= , the exclusive ordered comparisons < and > specifically exclude pre-releases, post-releases, and local versions of the specified version.","title":"Ordered comparison"},{"location":"config/dependency/#arbitrary-equality","text":"Though heavily discouraged, arbitrary equality comparisons allow for simple string matching without any version semantics, for example ===foobar .","title":"Arbitrary equality"},{"location":"config/dependency/#environment-markers","text":"Environment markers allow for dependencies to only be installed when certain conditions are met. For example, if you need to install the latest version of cryptography that is available for a given Python major version you could define the following: cryptography==3.3.2; python_version < \"3\" cryptography>=35.0; python_version > \"3\" Alternatively, if you only need it on Python 3 when running on Windows you could do: cryptography; python_version ~= \"3.0\" and platform_system == \"Windows\" The available environment markers are as follows. Marker Python equivalent Examples os_name import os os.name posix java sys_platform import sys sys.platform linux win32 darwin platform_machine import platform platform.machine() x86_64 platform_python_implementation import platform platform.python_implementation() CPython Jython platform_release import platform platform.release() 1.8.0_51 3.14.1-x86_64-linode39 platform_system import platform platform.system() Linux Windows Darwin platform_version import platform platform.version() 10.0.19041 #1 SMP Fri Apr 2 22:23:49 UTC 2021 python_version import platform '.'.join(platform.python_version_tuple()[:2]) 2.7 3.10 python_full_version import platform platform.python_version() 2.7.18 3.11.0b1 implementation_name import sys sys.implementation.name cpython implementation_version See here 2.7.18 3.11.0b1","title":"Environment markers"},{"location":"config/dependency/#features","text":"You can select groups of optional dependencies to install using the extras syntax. For example, if a dependency named foo defined the following: pyproject.toml [project.optional-dependencies] crypto = [ \"PyJWT\" , \"cryptography\" , ] fastjson = [ \"orjson\" , ] cli = [ \"prompt-toolkit\" , \"colorama; platform_system == 'Windows'\" , ] You can select the cli and crypto features like so: foo[cli,crypto]==1.* Note that the features come immediately after the package name, before any version specifiers .","title":"Features"},{"location":"config/dependency/#direct-references","text":"Instead of using normal version specifiers and fetching packages from an index like PyPI , you can define exact sources using direct references with an explicit URI . Direct references are not meant to be used for dependencies of a published project but rather are used for defining dependencies for an environment .","title":"Direct references"},{"location":"config/dependency/#version-control-systems","text":"Various version control systems (VCS) are supported as long as the associated executable is available along your PATH. VCS direct references are defined using one of the following formats: <SCHEME>://<PATH> <SCHEME>://<PATH>@<REVISION> You may also append a #subdirectory=<PATH> component for specifying the relative path to the Python package when it is not located at the root e.g. #subdirectory=lib/foo . For more information, refer to this .","title":"Version control systems"},{"location":"config/dependency/#supported-vcs","text":"Git Mercurial Subversion Bazaar Executable Schemes Revisions Example git git+file git+https git+ssh git+http git+git git Commit hash Tag name Branch name git+https://github.com/org/proj.git@v1 Executable Schemes Revisions Example hg hg+file hg+https hg+ssh hg+http hg+static-http Revision hash Revision number Tag name Branch name hg+file:///path/to/proj@v1 Executable Schemes Revisions Example svn svn+https svn+ssh svn+http svn+svn svn Revision number svn+file:///path/to/proj Executable Schemes Revisions Example bzr bzr+https bzr+ssh bzr+sftp bzr+lp bzr+http bzr+ftp Revision number Tag name bzr+lp:proj@v1","title":"Supported VCS"},{"location":"config/dependency/#local","text":"You can install local packages with the file scheme in the following format: file://<HOST>/<PATH> The <HOST> is only used on Windows systems, where it can refer to a network share. If omitted it is assumed to be localhost and the third slash must still be present. The <PATH> can refer to a source archive, a wheel, or a directory containing a Python package. Type Unix Windows Source archive file:///path/to/pkg.tar.gz file:///c:/path/to/pkg.tar.gz Wheel file:///path/to/pkg.whl file:///c:/path/to/pkg.whl Directory file:///path/to/pkg file:///c:/path/to/pkg You may also specify paths relative to your project's root directory on all platforms by omitting the leading slashes and beginning the path with a dot: file:./pkg_inside_project file:../pkg_alongside_project","title":"Local"},{"location":"config/dependency/#remote","text":"You can install source archives and wheels by simply referring to a URL: https://github.com/psf/black/archive/refs/tags/21.10b0.zip https://download.pytorch.org/whl/cu102/torch-1.10.0%2Bcu102-cp39-cp39-linux_x86_64.whl An expected hash value may be specified by appending a #<HASH_ALGORITHM>=<EXPECTED_HASH> component: https://github.com/psf/requests/archive/refs/tags/v2.26.0.zip#sha256=eb729a757f01c10546ebd179ae2aec852dd0d7f8ada2328ccf4558909d859985 If the hash differs from the expected hash, the installation will fail. It is recommended that only hashes which are unconditionally provided by the latest version of the standard library's hashlib module be used for hashes. As of Python 3.10, that list consists of: md5 sha1 sha224 sha256 sha384 sha512 blake2b blake2s","title":"Remote"},{"location":"config/environment/","text":"Environment configuration \u00b6 All environments are defined as sections within the tool.hatch.envs table. pyproject.toml [tool.hatch.envs.<ENV_NAME>] Unless an environment is explicitly selected on the command line, the default environment will be used. The type of this environment defaults to virtual . Inheritance \u00b6 All environments inherit from the environment defined by its template option, which defaults to default . So for the following configuration: pyproject.toml [tool.hatch.envs.foo] type = \"baz\" skip-install = true [tool.hatch.envs.bar] template = \"foo\" skip-install = false the environment bar will be of type baz with skip-install set to false . Dependencies \u00b6 You can install dependencies in addition to the ones defined by your project's metadata . pyproject.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] Installation \u00b6 Features \u00b6 If your project defines optional dependencies , you can select which groups to install using the features option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.envs.nightly] features = [ \"server\" , \"grpc\" , ] Dev mode \u00b6 By default, environments will always reflect the current state of your project on disk. Set dev-mode to false to disable this behavior: pyproject.toml [tool.hatch.envs.static] dev-mode = false Skip install \u00b6 By default, environments will install your project during creation. To ignore this step, set skip-install to true : pyproject.toml [tool.hatch.envs.lint] skip-install = true Variables \u00b6 You can define environment variables with the env-vars option: pyproject.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\" Scripts \u00b6 You can define named scripts that may be executed or referenced at the beginning of other scripts. For example, in the following configuration: pyproject.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [tool.hatch.envs.default.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" the run script would be expanded to: pytest --cov-config=pyproject.toml --cov=pkg --cov=tests --no-cov Scripts can also be defined as an array of strings. pyproject.toml [tool.hatch.envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [tool.hatch.envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] Tip Scripts inherit from parent environments just like options. Commands \u00b6 All commands are able to use any defined scripts . Pre-install \u00b6 You can run commands immediately before environments install your project. pyproject.toml [tool.hatch.envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ] Post-install \u00b6 You can run commands immediately after environments install your project. pyproject.toml [tool.hatch.envs.<ENV_NAME>] post-install-commands = [ \"...\" , ] Type \u00b6 An environment's type determines which environment plugin will be used for management. The only built-in environment type is virtual , which uses the standard virtualenv tool.","title":"Environments"},{"location":"config/environment/#environment-configuration","text":"All environments are defined as sections within the tool.hatch.envs table. pyproject.toml [tool.hatch.envs.<ENV_NAME>] Unless an environment is explicitly selected on the command line, the default environment will be used. The type of this environment defaults to virtual .","title":"Environment configuration"},{"location":"config/environment/#inheritance","text":"All environments inherit from the environment defined by its template option, which defaults to default . So for the following configuration: pyproject.toml [tool.hatch.envs.foo] type = \"baz\" skip-install = true [tool.hatch.envs.bar] template = \"foo\" skip-install = false the environment bar will be of type baz with skip-install set to false .","title":"Inheritance"},{"location":"config/environment/#dependencies","text":"You can install dependencies in addition to the ones defined by your project's metadata . pyproject.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ]","title":"Dependencies"},{"location":"config/environment/#installation","text":"","title":"Installation"},{"location":"config/environment/#features","text":"If your project defines optional dependencies , you can select which groups to install using the features option, which may be defined as either an array of strings or a comma-separated string: pyproject.toml [tool.hatch.envs.nightly] features = [ \"server\" , \"grpc\" , ]","title":"Features"},{"location":"config/environment/#dev-mode","text":"By default, environments will always reflect the current state of your project on disk. Set dev-mode to false to disable this behavior: pyproject.toml [tool.hatch.envs.static] dev-mode = false","title":"Dev mode"},{"location":"config/environment/#skip-install","text":"By default, environments will install your project during creation. To ignore this step, set skip-install to true : pyproject.toml [tool.hatch.envs.lint] skip-install = true","title":"Skip install"},{"location":"config/environment/#variables","text":"You can define environment variables with the env-vars option: pyproject.toml [tool.hatch.envs.docs] dependencies = [ \"mkdocs\" ] [tool.hatch.envs.docs.env-vars] SOURCE_DATE_EPOCH = \"1580601600\"","title":"Variables"},{"location":"config/environment/#scripts","text":"You can define named scripts that may be executed or referenced at the beginning of other scripts. For example, in the following configuration: pyproject.toml [tool.hatch.envs.test] dependencies = [ \"coverage[toml]\" , \"pytest\" , \"pytest-cov\" , \"pytest-mock\" , ] [tool.hatch.envs.default.scripts] run-coverage = \"pytest --cov-config=pyproject.toml --cov=pkg --cov=tests\" run = \"run-coverage --no-cov\" the run script would be expanded to: pytest --cov-config=pyproject.toml --cov=pkg --cov=tests --no-cov Scripts can also be defined as an array of strings. pyproject.toml [tool.hatch.envs.style] skip-install = true dependencies = [ \"flake8\" , \"black\" , \"isort\" , ] [tool.hatch.envs.style.scripts] check = [ \"flake8 .\" , \"black --check --diff .\" , \"isort --check-only --diff .\" , ] fmt = [ \"isort .\" , \"black .\" , \"check\" , ] Tip Scripts inherit from parent environments just like options.","title":"Scripts"},{"location":"config/environment/#commands","text":"All commands are able to use any defined scripts .","title":"Commands"},{"location":"config/environment/#pre-install","text":"You can run commands immediately before environments install your project. pyproject.toml [tool.hatch.envs.<ENV_NAME>] pre-install-commands = [ \"...\" , ]","title":"Pre-install"},{"location":"config/environment/#post-install","text":"You can run commands immediately after environments install your project. pyproject.toml [tool.hatch.envs.<ENV_NAME>] post-install-commands = [ \"...\" , ]","title":"Post-install"},{"location":"config/environment/#type","text":"An environment's type determines which environment plugin will be used for management. The only built-in environment type is virtual , which uses the standard virtualenv tool.","title":"Type"},{"location":"config/hatch/","text":"Hatch configuration \u00b6 Configuration for Hatch itself is stored in a config.toml file located by default in one of the following platform-specific directories. Platform Path macOS ~/Library/Preferences/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_CONFIG_HOME/hatch (the XDG_CONFIG_HOME environment variable default is ~/.config ) You can select a custom path to the file using the --config root option or by setting the HATCH_CONFIG environment variable. The file can be managed by the config command group. Mode \u00b6 The mode key controls how Hatch selects the project to work on. Local \u00b6 config.toml mode = \"local\" By default, Hatch will look for a pyproject.toml or setup.py file in the current working directory and any parent directories. The directory storing the first found file will be considered the project root. Project \u00b6 config.toml mode = \"project\" project = \"proj1\" [projects] proj1 = \"/path/to/project1\" proj2 = { \"location\" : \"/path/to/project2\" } [dirs] project = [ \"/path/to/monorepo1\" , \"/path/to/monorepo2\" ] In this mode, Hatch will only work on the selected project . The project is located using multiple heuristics: If the project is defined in the projects table then it must be a string, or an inline table with a location key, that is the full path to the project. If the project matches a subdirectory in any of the directories listed in dirs.project , then that will be used as the project root. An error will occur if the project cannot be found. You can use the config set command to change the project you are working on: $ hatch config set project proj2 New setting: project = \"proj2\" Aware \u00b6 config.toml mode = \"aware\" This is essentially the local mode with a fallback to the project mode. Shell \u00b6 You can control the shell used to enter environments with the shell key. If defined as a string, it must be the name of one of the supported shells and be available along your PATH . config.toml shell = \"fish\" If the executable name of your shell differs from the supported name, you can define the shell as a table with name and path keys. config.toml [shell] name = \"powershell\" path = \"pwsh\" Supported \u00b6 Shell Name macOS Windows Unix Bash bash Command Prompt cmd C shell csh fish fish Nushell nu PowerShell powershell tcsh tcsh xonsh xonsh Z shell zsh Default \u00b6 On Windows systems Hatch will use the COMSPEC environment variable, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash . Directories \u00b6 Data \u00b6 config.toml [dirs] data = \"...\" This is the directory that is used to persist data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Application Support/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_DATA_HOME/hatch (the XDG_DATA_HOME environment variable default is ~/.local/share ) You can select a custom path to the directory using the --data-dir root option or by setting the HATCH_DATA_DIR environment variable. Cache \u00b6 config.toml [dirs] cache = \"...\" This is the directory that is used to cache data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Caches/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch\\Cache Unix $XDG_CACHE_HOME/hatch (the XDG_CACHE_HOME environment variable default is ~/.cache ) You can select a custom path to the directory using the --cache-dir root option or by setting the HATCH_CACHE_DIR environment variable. Environments \u00b6 config.toml [dirs] env = \"...\" This determines where to store environments, with the full path being <VALUE>/env/<ENV_TYPE> . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/env/<ENV_TYPE> local <PROJECT_ROOT>/.env/<ENV_TYPE> Python installations \u00b6 config.toml [dirs] python = \"...\" This determines where to install specific versions of Python, with the full path being <VALUE>/pythons . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/pythons shared ~/.pythons Terminal \u00b6 You can configure how all output types are displayed using the terminal table. These settings are also applied to all plugins. config.toml [terminal] error = \"...\" ... The types of output are as follows. Note that the verbosity indicates the minimum level at which the output is displayed. Type Default Verbosity Description debug bold 1 Messages that are not useful for most user experiences error bold_red -2 Messages indicating some unrecoverable error info bold 0 Messages conveying basic information success bold_cyan 0 Messages indicating some positive outcome waiting bold_magenta 0 Messages shown before potentially time consuming operations warning bold_yellow -1 Messages conveying important information See the full color chart and the subsequent sections for guidance on valid values.","title":"Hatch"},{"location":"config/hatch/#hatch-configuration","text":"Configuration for Hatch itself is stored in a config.toml file located by default in one of the following platform-specific directories. Platform Path macOS ~/Library/Preferences/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_CONFIG_HOME/hatch (the XDG_CONFIG_HOME environment variable default is ~/.config ) You can select a custom path to the file using the --config root option or by setting the HATCH_CONFIG environment variable. The file can be managed by the config command group.","title":"Hatch configuration"},{"location":"config/hatch/#mode","text":"The mode key controls how Hatch selects the project to work on.","title":"Mode"},{"location":"config/hatch/#local","text":"config.toml mode = \"local\" By default, Hatch will look for a pyproject.toml or setup.py file in the current working directory and any parent directories. The directory storing the first found file will be considered the project root.","title":"Local"},{"location":"config/hatch/#project","text":"config.toml mode = \"project\" project = \"proj1\" [projects] proj1 = \"/path/to/project1\" proj2 = { \"location\" : \"/path/to/project2\" } [dirs] project = [ \"/path/to/monorepo1\" , \"/path/to/monorepo2\" ] In this mode, Hatch will only work on the selected project . The project is located using multiple heuristics: If the project is defined in the projects table then it must be a string, or an inline table with a location key, that is the full path to the project. If the project matches a subdirectory in any of the directories listed in dirs.project , then that will be used as the project root. An error will occur if the project cannot be found. You can use the config set command to change the project you are working on: $ hatch config set project proj2 New setting: project = \"proj2\"","title":"Project"},{"location":"config/hatch/#aware","text":"config.toml mode = \"aware\" This is essentially the local mode with a fallback to the project mode.","title":"Aware"},{"location":"config/hatch/#shell","text":"You can control the shell used to enter environments with the shell key. If defined as a string, it must be the name of one of the supported shells and be available along your PATH . config.toml shell = \"fish\" If the executable name of your shell differs from the supported name, you can define the shell as a table with name and path keys. config.toml [shell] name = \"powershell\" path = \"pwsh\"","title":"Shell"},{"location":"config/hatch/#supported","text":"Shell Name macOS Windows Unix Bash bash Command Prompt cmd C shell csh fish fish Nushell nu PowerShell powershell tcsh tcsh xonsh xonsh Z shell zsh","title":"Supported"},{"location":"config/hatch/#default","text":"On Windows systems Hatch will use the COMSPEC environment variable, defaulting to cmd . Otherwise the SHELL environment variable will be used, defaulting to bash .","title":"Default"},{"location":"config/hatch/#directories","text":"","title":"Directories"},{"location":"config/hatch/#data","text":"config.toml [dirs] data = \"...\" This is the directory that is used to persist data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Application Support/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch Unix $XDG_DATA_HOME/hatch (the XDG_DATA_HOME environment variable default is ~/.local/share ) You can select a custom path to the directory using the --data-dir root option or by setting the HATCH_DATA_DIR environment variable.","title":"Data"},{"location":"config/hatch/#cache","text":"config.toml [dirs] cache = \"...\" This is the directory that is used to cache data. By default it is set to one of the following platform-specific directories. Platform Path macOS ~/Library/Caches/hatch Windows %USERPROFILE%\\AppData\\Local\\hatch\\Cache Unix $XDG_CACHE_HOME/hatch (the XDG_CACHE_HOME environment variable default is ~/.cache ) You can select a custom path to the directory using the --cache-dir root option or by setting the HATCH_CACHE_DIR environment variable.","title":"Cache"},{"location":"config/hatch/#environments","text":"config.toml [dirs] env = \"...\" This determines where to store environments, with the full path being <VALUE>/env/<ENV_TYPE> . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/env/<ENV_TYPE> local <PROJECT_ROOT>/.env/<ENV_TYPE>","title":"Environments"},{"location":"config/hatch/#python-installations","text":"config.toml [dirs] python = \"...\" This determines where to install specific versions of Python, with the full path being <VALUE>/pythons . The following values have special meanings. Value Path isolated (default) <DATA_DIR>/pythons shared ~/.pythons","title":"Python installations"},{"location":"config/hatch/#terminal","text":"You can configure how all output types are displayed using the terminal table. These settings are also applied to all plugins. config.toml [terminal] error = \"...\" ... The types of output are as follows. Note that the verbosity indicates the minimum level at which the output is displayed. Type Default Verbosity Description debug bold 1 Messages that are not useful for most user experiences error bold_red -2 Messages indicating some unrecoverable error info bold 0 Messages conveying basic information success bold_cyan 0 Messages indicating some positive outcome waiting bold_magenta 0 Messages shown before potentially time consuming operations warning bold_yellow -1 Messages conveying important information See the full color chart and the subsequent sections for guidance on valid values.","title":"Terminal"},{"location":"config/metadata/","text":"Project metadata \u00b6 Project metadata is stored in a pyproject.toml file located at the root of a project's tree and is based entirely on PEP 621 . Name \u00b6 REQUIRED The name of the project. pyproject.toml [project] name = \"your-app\" Version \u00b6 REQUIRED pyproject.toml Dynamic Static See the dedicated versioning section. [project] ... dynamic = [ \"version\" ] [tool.hatch.version] path = \"...\" [project] ... version = \"0.0.1\" Description \u00b6 A brief summary of the project. pyproject.toml [project] ... description = '...' Readme \u00b6 The full description of the project. pyproject.toml Simple Complex The file extension must be .md or .rst . [project] ... readme = \"README.md\" The content_type field must be set to text/markdown or text/x-rst . File Text A charset field may also be set to instruct which encoding to use for reading the file, defaulting to utf-8 . [project] ... readme = { \"file\" : \"README.md\" , \"content_type\" : \"text/markdown\" } The content_type field must be set to text/markdown or text/x-rst . [project] ... readme = { \"text\" : \"...\" , \"content_type\" : \"text/markdown\" } Python support \u00b6 The Python version requirements of the project. pyproject.toml [project] ... requires-python = \">=3.8\" License \u00b6 pyproject.toml SPDX identifier Custom For more information, see PEP 639 . [project] ... license = \"Apache-2.0 or MIT\" File Text [project] ... license = { \"file\" : \"LICENSE.txt\" } [project] ... license = { \"text\" : \"...\" } Ownership \u00b6 The people or organizations considered to be the authors or maintainers of the project. The exact meaning is open to interpretation; it may list the original or primary authors, current maintainers, or owners of the package. If the values are the same, prefer only the use of the authors field. pyproject.toml [project] ... authors = [ { name = \"...\" , email = \"...\" }, ] maintainers = [ { name = \"...\" , email = \"...\" }, ] Keywords \u00b6 The keywords used to assist in the discovery of the project. pyproject.toml [project] ... keywords = [ \"...\" , ] Classifiers \u00b6 The trove classifiers that apply to the project. pyproject.toml [project] ... classifiers = [ \"...\" , ] URLs \u00b6 A table of URLs where the key is the URL label and the value is the URL itself. pyproject.toml [project.urls] Documentation = \"...\" \"Source code\" = \"...\" Dependencies \u00b6 The format is based on PEP 631 . See the dependency specification section for more information. Required \u00b6 pyproject.toml [project] ... dependencies = [ \"...\" , ] Optional \u00b6 pyproject.toml [project.optional-dependencies] option1 = [ \"...\" , ] option2 = [ \"...\" , ] Entry points \u00b6 Entry points are a mechanism for the project to advertise components it provides to be discovered and used by other code. CLI \u00b6 pyproject.toml [project.scripts] cli-name = \"pkg.subpkg:func\" GUI \u00b6 pyproject.toml [project.gui-scripts] gui-name = \"pkg.subpkg:func\" Plugins \u00b6 pyproject.toml [project.entry-points.plugin-namespace] plugin-name1 = \"pkg.subpkg1\" plugin-name2 = \"pkg.subpkg2:func\"","title":"Metadata"},{"location":"config/metadata/#project-metadata","text":"Project metadata is stored in a pyproject.toml file located at the root of a project's tree and is based entirely on PEP 621 .","title":"Project metadata"},{"location":"config/metadata/#name","text":"REQUIRED The name of the project. pyproject.toml [project] name = \"your-app\"","title":"Name"},{"location":"config/metadata/#version","text":"REQUIRED pyproject.toml Dynamic Static See the dedicated versioning section. [project] ... dynamic = [ \"version\" ] [tool.hatch.version] path = \"...\" [project] ... version = \"0.0.1\"","title":"Version"},{"location":"config/metadata/#description","text":"A brief summary of the project. pyproject.toml [project] ... description = '...'","title":"Description"},{"location":"config/metadata/#readme","text":"The full description of the project. pyproject.toml Simple Complex The file extension must be .md or .rst . [project] ... readme = \"README.md\" The content_type field must be set to text/markdown or text/x-rst . File Text A charset field may also be set to instruct which encoding to use for reading the file, defaulting to utf-8 . [project] ... readme = { \"file\" : \"README.md\" , \"content_type\" : \"text/markdown\" } The content_type field must be set to text/markdown or text/x-rst . [project] ... readme = { \"text\" : \"...\" , \"content_type\" : \"text/markdown\" }","title":"Readme"},{"location":"config/metadata/#python-support","text":"The Python version requirements of the project. pyproject.toml [project] ... requires-python = \">=3.8\"","title":"Python support"},{"location":"config/metadata/#license","text":"pyproject.toml SPDX identifier Custom For more information, see PEP 639 . [project] ... license = \"Apache-2.0 or MIT\" File Text [project] ... license = { \"file\" : \"LICENSE.txt\" } [project] ... license = { \"text\" : \"...\" }","title":"License"},{"location":"config/metadata/#ownership","text":"The people or organizations considered to be the authors or maintainers of the project. The exact meaning is open to interpretation; it may list the original or primary authors, current maintainers, or owners of the package. If the values are the same, prefer only the use of the authors field. pyproject.toml [project] ... authors = [ { name = \"...\" , email = \"...\" }, ] maintainers = [ { name = \"...\" , email = \"...\" }, ]","title":"Ownership"},{"location":"config/metadata/#keywords","text":"The keywords used to assist in the discovery of the project. pyproject.toml [project] ... keywords = [ \"...\" , ]","title":"Keywords"},{"location":"config/metadata/#classifiers","text":"The trove classifiers that apply to the project. pyproject.toml [project] ... classifiers = [ \"...\" , ]","title":"Classifiers"},{"location":"config/metadata/#urls","text":"A table of URLs where the key is the URL label and the value is the URL itself. pyproject.toml [project.urls] Documentation = \"...\" \"Source code\" = \"...\"","title":"URLs"},{"location":"config/metadata/#dependencies","text":"The format is based on PEP 631 . See the dependency specification section for more information.","title":"Dependencies"},{"location":"config/metadata/#required","text":"pyproject.toml [project] ... dependencies = [ \"...\" , ]","title":"Required"},{"location":"config/metadata/#optional","text":"pyproject.toml [project.optional-dependencies] option1 = [ \"...\" , ] option2 = [ \"...\" , ]","title":"Optional"},{"location":"config/metadata/#entry-points","text":"Entry points are a mechanism for the project to advertise components it provides to be discovered and used by other code.","title":"Entry points"},{"location":"config/metadata/#cli","text":"pyproject.toml [project.scripts] cli-name = \"pkg.subpkg:func\"","title":"CLI"},{"location":"config/metadata/#gui","text":"pyproject.toml [project.gui-scripts] gui-name = \"pkg.subpkg:func\"","title":"GUI"},{"location":"config/metadata/#plugins","text":"pyproject.toml [project.entry-points.plugin-namespace] plugin-name1 = \"pkg.subpkg1\" plugin-name2 = \"pkg.subpkg2:func\"","title":"Plugins"},{"location":"plugins/about/","text":"Plugins \u00b6 Hatch utilizes pluggy for its plugin functionality. Overview \u00b6 All plugins provide registration hooks that return one or more classes that inherit from a particular type interface. Each registration hook must be decorated by Hatch's hook marker. For example, if you wanted to create a new kind of environment you could do: hooks.py from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment The hooks can return a single class or a list of classes. Every class must define an attribute called PLUGIN_NAME that users will select when they wish to use the plugin. So in the example above, the class might be defined like: plugin.py ... class SpecialEnvironment ( ... ): PLUGIN_NAME = 'special' ... Project configuration \u00b6 Naming \u00b6 It is recommended that plugin project names are prefixed with hatch- . For example, if you wanted to make a plugin that provides some functionality for a product named foo you might do: pyproject.toml [project] name = \"hatch-foo\" Discovery \u00b6 You'll need to define your project as a Python plugin for Hatch: pyproject.toml [project.entry-points.hatch] foo = \"pkg.hooks\" The name of the plugin should be the project name (excluding any hatch- prefix) and the path should represent the module that contains the registration hooks. Types \u00b6 Hatchling \u00b6 These are all involved in building projects and therefore any defined dependencies are automatically installed in each build environment. Builder Build hook Version source Hatch \u00b6 These must be manually installed in the same environment as Hatch itself. Environment Publisher Version scheme","title":"About"},{"location":"plugins/about/#plugins","text":"Hatch utilizes pluggy for its plugin functionality.","title":"Plugins"},{"location":"plugins/about/#overview","text":"All plugins provide registration hooks that return one or more classes that inherit from a particular type interface. Each registration hook must be decorated by Hatch's hook marker. For example, if you wanted to create a new kind of environment you could do: hooks.py from hatchling.plugin import hookimpl from .plugin import SpecialEnvironment @hookimpl def hatch_register_environment (): return SpecialEnvironment The hooks can return a single class or a list of classes. Every class must define an attribute called PLUGIN_NAME that users will select when they wish to use the plugin. So in the example above, the class might be defined like: plugin.py ... class SpecialEnvironment ( ... ): PLUGIN_NAME = 'special' ...","title":"Overview"},{"location":"plugins/about/#project-configuration","text":"","title":"Project configuration"},{"location":"plugins/about/#naming","text":"It is recommended that plugin project names are prefixed with hatch- . For example, if you wanted to make a plugin that provides some functionality for a product named foo you might do: pyproject.toml [project] name = \"hatch-foo\"","title":"Naming"},{"location":"plugins/about/#discovery","text":"You'll need to define your project as a Python plugin for Hatch: pyproject.toml [project.entry-points.hatch] foo = \"pkg.hooks\" The name of the plugin should be the project name (excluding any hatch- prefix) and the path should represent the module that contains the registration hooks.","title":"Discovery"},{"location":"plugins/about/#types","text":"","title":"Types"},{"location":"plugins/about/#hatchling","text":"These are all involved in building projects and therefore any defined dependencies are automatically installed in each build environment. Builder Build hook Version source","title":"Hatchling"},{"location":"plugins/about/#hatch","text":"These must be manually installed in the same environment as Hatch itself. Environment Publisher Version scheme","title":"Hatch"},{"location":"plugins/build-hook/","text":"Build hook plugins \u00b6 A build hook provides code that will be executed at various stages of the build process. See the documentation for build hook configuration . Overview \u00b6 Build hooks run for every selected version of build targets. The initialization stage occurs immediately before each build and the finalization stage occurs immediately after. Each stage has the opportunity to view or modify build data . Build data \u00b6 Build data is a simple mapping whose contents can influence the behavior of builds. Which fields are recognized depends on each build target. The following fields are always present and recognized by the build system itself: Field Type Description artifacts list [ str ] This is a list of extra paths to artifacts and should generally only be appended to Built-in \u00b6 Custom \u00b6 This is a custom class in a given Python file that inherits from the BuildHookInterface . Configuration \u00b6 The build hook plugin name is custom . pyproject.toml [tool.hatch.build.hooks.custom] [tool.hatch.build.targets.<TARGET_NAME>.hooks.custom] An option path is used to specify the path of the Python file, defaulting to build.py . Example \u00b6 build.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class CustomBuildHook ( BuildHookInterface ): ... If multiple subclasses are found, you must define a function named get_build_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom . BuildHookInterface \u00b6 Example usage: plugin.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class SpecialBuildHook ( BuildHookInterface ): PLUGIN_NAME = 'special' ... PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . config property readonly \u00b6 The cumulative hook configuration. directory property readonly \u00b6 The build directory. root property readonly \u00b6 The root of the project tree. target_name property readonly \u00b6 The plugin name of the build target. finalize ( self , version , build_data , artifact_path ) \u00b6 This occurs immediately after each build and will not run if the --hooks-only flag was passed to the build command. The build data will reflect any modifications done by the target during the build. Source code in hatchling/builders/hooks/plugin/interface.py def finalize ( self , version , build_data , artifact_path ): \"\"\" This occurs immediately after each build and will not run if the `--hooks-only` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. The build data will reflect any modifications done by the target during the build. \"\"\" initialize ( self , version , build_data ) \u00b6 This occurs immediately before each build. Any modifications to the build data will be seen by the build target. Source code in hatchling/builders/hooks/plugin/interface.py def initialize ( self , version , build_data ): \"\"\" This occurs immediately before each build. Any modifications to the build data will be seen by the build target. \"\"\"","title":"Build hook"},{"location":"plugins/build-hook/#build-hook-plugins","text":"A build hook provides code that will be executed at various stages of the build process. See the documentation for build hook configuration .","title":"Build hook plugins"},{"location":"plugins/build-hook/#overview","text":"Build hooks run for every selected version of build targets. The initialization stage occurs immediately before each build and the finalization stage occurs immediately after. Each stage has the opportunity to view or modify build data .","title":"Overview"},{"location":"plugins/build-hook/#build-data","text":"Build data is a simple mapping whose contents can influence the behavior of builds. Which fields are recognized depends on each build target. The following fields are always present and recognized by the build system itself: Field Type Description artifacts list [ str ] This is a list of extra paths to artifacts and should generally only be appended to","title":"Build data"},{"location":"plugins/build-hook/#built-in","text":"","title":"Built-in"},{"location":"plugins/build-hook/#custom","text":"This is a custom class in a given Python file that inherits from the BuildHookInterface .","title":"Custom"},{"location":"plugins/build-hook/#configuration","text":"The build hook plugin name is custom . pyproject.toml [tool.hatch.build.hooks.custom] [tool.hatch.build.targets.<TARGET_NAME>.hooks.custom] An option path is used to specify the path of the Python file, defaulting to build.py .","title":"Configuration"},{"location":"plugins/build-hook/#example","text":"build.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class CustomBuildHook ( BuildHookInterface ): ... If multiple subclasses are found, you must define a function named get_build_hook that returns the desired build hook. Note Any defined PLUGIN_NAME is ignored and will always be custom .","title":"Example"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface","text":"Example usage: plugin.py from hatchling.builders.hooks.plugin.interface import BuildHookInterface class SpecialBuildHook ( BuildHookInterface ): PLUGIN_NAME = 'special' ...","title":"BuildHookInterface"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.config","text":"The cumulative hook configuration.","title":"config"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.directory","text":"The build directory.","title":"directory"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.root","text":"The root of the project tree.","title":"root"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.target_name","text":"The plugin name of the build target.","title":"target_name"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.finalize","text":"This occurs immediately after each build and will not run if the --hooks-only flag was passed to the build command. The build data will reflect any modifications done by the target during the build. Source code in hatchling/builders/hooks/plugin/interface.py def finalize ( self , version , build_data , artifact_path ): \"\"\" This occurs immediately after each build and will not run if the `--hooks-only` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. The build data will reflect any modifications done by the target during the build. \"\"\"","title":"finalize()"},{"location":"plugins/build-hook/#hatchling.builders.hooks.plugin.interface.BuildHookInterface.initialize","text":"This occurs immediately before each build. Any modifications to the build data will be seen by the build target. Source code in hatchling/builders/hooks/plugin/interface.py def initialize ( self , version , build_data ): \"\"\" This occurs immediately before each build. Any modifications to the build data will be seen by the build target. \"\"\"","title":"initialize()"},{"location":"plugins/builder/","text":"Builder plugins \u00b6 See the documentation for build configuration . Built-in \u00b6 Wheel \u00b6 A wheel is a binary distribution of a Python package that can be installed directly into an environment. Configuration \u00b6 The builder plugin name is wheel . pyproject.toml [tool.hatch.build.targets.wheel] Extra options \u00b6 Option Default Description zip-safe true Whether or not to write metadata indicating that the package is able to run directly as a ZIP file; can be overriden by build hooks core-metadata-version \"2.1\" The version of core metadata to use Versions \u00b6 Version Description 1 (default) Default file selection \u00b6 When the user has not set any file selection options, every file will be included that is inside any Python package that does not start with the word test . Caveat Native namespace packages would not be included by default because one of the heuristics that is used is the presence of a __init__.py file. Build data \u00b6 This is data that can be modified by build hooks . Data Default Description tag The full tag part of the filename (e.g. py3-none-any ), defaulting to a cross-platform wheel with the supported major versions of Python based on project metadata infer_tag False When tag is not set, this may be enabled to use the option most specific to the platform, Python interpreter, and ABI zip_safe Whether or not to write metadata indicating that the package is able to run directly as a ZIP file, defaulting to the zip-safe option Source distribution \u00b6 A source distribution, or sdist , is an archive of Python \"source code\". Although largely unspecified, by convention it should include everything that is required to build a wheel without making network requests. Configuration \u00b6 The builder plugin name is sdist . pyproject.toml [tool.hatch.build.targets.sdist] Extra options \u00b6 Option Default Description support-legacy true Whether or not to include a setup.py file to support legacy installation mechanisms core-metadata-version \"1.2\" The version of core metadata to use Versions \u00b6 Version Description 1 (default) Default file selection \u00b6 When the user has not set any file selection options, all files that are not ignored by your VCS will be included. Custom \u00b6 This is a custom class in a given Python file that inherits from the BuilderInterface . Configuration \u00b6 The builder plugin name is custom . pyproject.toml [tool.hatch.build.targets.custom] An option path is used to specify the path of the Python file, defaulting to build.py . Example \u00b6 build.py from hatchling.builders.plugin.interface import BuilderInterface class CustomBuilder ( BuilderInterface ): ... If multiple subclasses are found, you must define a function named get_builder that returns the desired builder. Note Any defined PLUGIN_NAME is ignored and will always be custom . BuilderInterface \u00b6 Example usage: plugin.py from hatchling.builders.plugin.interface import BuilderInterface class SpecialBuilder ( BuilderInterface ): PLUGIN_NAME = 'special' ... PLUGIN_NAME \u00b6 The name used for selection. app property readonly \u00b6 An instance of Application . build_config property readonly \u00b6 pyproject.toml [tool.hatch.build] dev_mode_dirs property readonly \u00b6 Directories which must be added to Python's search path in dev mode . reproducible property readonly \u00b6 Whether or not the target should be built in a reproducible manner, defaulting to true. root property readonly \u00b6 The root of the project tree. target_config property readonly \u00b6 pyproject.toml [tool.hatch.build.targets.<PLUGIN_NAME>] clean ( self , directory , versions ) \u00b6 Called before builds if the -c / --clean flag was passed to the build command. Source code in hatchling/builders/plugin/interface.py def clean ( self , directory , versions ): \"\"\" Called before builds if the `-c`/`--clean` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. \"\"\" get_default_build_data ( self ) \u00b6 A mapping that can be modified by build hooks to influence the behavior of builds. Source code in hatchling/builders/plugin/interface.py def get_default_build_data ( self ): \"\"\" A mapping that can be modified by [build hooks](build-hook.md) to influence the behavior of builds. \"\"\" return {} get_default_versions ( self ) \u00b6 A list of versions to build when users do not specify any, defaulting to all versions. Source code in hatchling/builders/plugin/interface.py def get_default_versions ( self ): \"\"\" A list of versions to build when users do not specify any, defaulting to all versions. \"\"\" return list ( self . get_version_api ()) get_version_api ( self ) \u00b6 A mapping of str versions to a callable that is used for building. Each callable must have the following signature: def ... ( build_dir : str , build_data : dict ) -> str : The return value must be the absolute path to the built artifact. Source code in hatchling/builders/plugin/interface.py def get_version_api ( self ): \"\"\" A mapping of `str` versions to a callable that is used for building. Each callable must have the following signature: ```python def ...(build_dir: str, build_data: dict) -> str: ``` The return value must be the absolute path to the built artifact. \"\"\" raise NotImplementedError recurse_project_files ( self ) \u00b6 Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three str attributes: path - the absolute path relative_path - the path relative to the project root distribution_path - the path to be distributed as Source code in hatchling/builders/plugin/interface.py def recurse_project_files ( self ): \"\"\" Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three `str` attributes: - `path` - the absolute path - `relative_path` - the path relative to the project root - `distribution_path` - the path to be distributed as \"\"\" for root , dirs , files in os . walk ( self . root ): relative_path = os . path . relpath ( root , self . root ) # First iteration if relative_path == '.' : relative_path = '' dirs [:] = sorted ( d for d in dirs if not ( self . ignore_directory ( d ) or self . path_is_excluded ( os . path . join ( relative_path , d ))) ) if self . ignore_files ( files ): continue for f in sorted ( files ): relative_file_path = os . path . join ( relative_path , f ) if self . include_path ( relative_file_path ): yield IncludedFile ( os . path . join ( root , f ), relative_file_path , self . get_distribution_path ( relative_file_path ) )","title":"Builder"},{"location":"plugins/builder/#builder-plugins","text":"See the documentation for build configuration .","title":"Builder plugins"},{"location":"plugins/builder/#built-in","text":"","title":"Built-in"},{"location":"plugins/builder/#wheel","text":"A wheel is a binary distribution of a Python package that can be installed directly into an environment.","title":"Wheel"},{"location":"plugins/builder/#configuration","text":"The builder plugin name is wheel . pyproject.toml [tool.hatch.build.targets.wheel]","title":"Configuration"},{"location":"plugins/builder/#extra-options","text":"Option Default Description zip-safe true Whether or not to write metadata indicating that the package is able to run directly as a ZIP file; can be overriden by build hooks core-metadata-version \"2.1\" The version of core metadata to use","title":"Extra options"},{"location":"plugins/builder/#versions","text":"Version Description 1 (default)","title":"Versions"},{"location":"plugins/builder/#default-file-selection","text":"When the user has not set any file selection options, every file will be included that is inside any Python package that does not start with the word test . Caveat Native namespace packages would not be included by default because one of the heuristics that is used is the presence of a __init__.py file.","title":"Default file selection"},{"location":"plugins/builder/#build-data","text":"This is data that can be modified by build hooks . Data Default Description tag The full tag part of the filename (e.g. py3-none-any ), defaulting to a cross-platform wheel with the supported major versions of Python based on project metadata infer_tag False When tag is not set, this may be enabled to use the option most specific to the platform, Python interpreter, and ABI zip_safe Whether or not to write metadata indicating that the package is able to run directly as a ZIP file, defaulting to the zip-safe option","title":"Build data"},{"location":"plugins/builder/#source-distribution","text":"A source distribution, or sdist , is an archive of Python \"source code\". Although largely unspecified, by convention it should include everything that is required to build a wheel without making network requests.","title":"Source distribution"},{"location":"plugins/builder/#configuration_1","text":"The builder plugin name is sdist . pyproject.toml [tool.hatch.build.targets.sdist]","title":"Configuration"},{"location":"plugins/builder/#extra-options_1","text":"Option Default Description support-legacy true Whether or not to include a setup.py file to support legacy installation mechanisms core-metadata-version \"1.2\" The version of core metadata to use","title":"Extra options"},{"location":"plugins/builder/#versions_1","text":"Version Description 1 (default)","title":"Versions"},{"location":"plugins/builder/#default-file-selection_1","text":"When the user has not set any file selection options, all files that are not ignored by your VCS will be included.","title":"Default file selection"},{"location":"plugins/builder/#custom","text":"This is a custom class in a given Python file that inherits from the BuilderInterface .","title":"Custom"},{"location":"plugins/builder/#configuration_2","text":"The builder plugin name is custom . pyproject.toml [tool.hatch.build.targets.custom] An option path is used to specify the path of the Python file, defaulting to build.py .","title":"Configuration"},{"location":"plugins/builder/#example","text":"build.py from hatchling.builders.plugin.interface import BuilderInterface class CustomBuilder ( BuilderInterface ): ... If multiple subclasses are found, you must define a function named get_builder that returns the desired builder. Note Any defined PLUGIN_NAME is ignored and will always be custom .","title":"Example"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface","text":"Example usage: plugin.py from hatchling.builders.plugin.interface import BuilderInterface class SpecialBuilder ( BuilderInterface ): PLUGIN_NAME = 'special' ...","title":"BuilderInterface"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.PLUGIN_NAME","text":"The name used for selection.","title":"PLUGIN_NAME"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.app","text":"An instance of Application .","title":"app"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.build_config","text":"pyproject.toml [tool.hatch.build]","title":"build_config"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.dev_mode_dirs","text":"Directories which must be added to Python's search path in dev mode .","title":"dev_mode_dirs"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.reproducible","text":"Whether or not the target should be built in a reproducible manner, defaulting to true.","title":"reproducible"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.root","text":"The root of the project tree.","title":"root"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.target_config","text":"pyproject.toml [tool.hatch.build.targets.<PLUGIN_NAME>]","title":"target_config"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.clean","text":"Called before builds if the -c / --clean flag was passed to the build command. Source code in hatchling/builders/plugin/interface.py def clean ( self , directory , versions ): \"\"\" Called before builds if the `-c`/`--clean` flag was passed to the [`build`](../cli/reference.md#hatch-build) command. \"\"\"","title":"clean()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_default_build_data","text":"A mapping that can be modified by build hooks to influence the behavior of builds. Source code in hatchling/builders/plugin/interface.py def get_default_build_data ( self ): \"\"\" A mapping that can be modified by [build hooks](build-hook.md) to influence the behavior of builds. \"\"\" return {}","title":"get_default_build_data()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_default_versions","text":"A list of versions to build when users do not specify any, defaulting to all versions. Source code in hatchling/builders/plugin/interface.py def get_default_versions ( self ): \"\"\" A list of versions to build when users do not specify any, defaulting to all versions. \"\"\" return list ( self . get_version_api ())","title":"get_default_versions()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.get_version_api","text":"A mapping of str versions to a callable that is used for building. Each callable must have the following signature: def ... ( build_dir : str , build_data : dict ) -> str : The return value must be the absolute path to the built artifact. Source code in hatchling/builders/plugin/interface.py def get_version_api ( self ): \"\"\" A mapping of `str` versions to a callable that is used for building. Each callable must have the following signature: ```python def ...(build_dir: str, build_data: dict) -> str: ``` The return value must be the absolute path to the built artifact. \"\"\" raise NotImplementedError","title":"get_version_api()"},{"location":"plugins/builder/#hatchling.builders.plugin.interface.BuilderInterface.recurse_project_files","text":"Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three str attributes: path - the absolute path relative_path - the path relative to the project root distribution_path - the path to be distributed as Source code in hatchling/builders/plugin/interface.py def recurse_project_files ( self ): \"\"\" Returns a consistently generated series of file objects for every file that should be distributed. Each file object has three `str` attributes: - `path` - the absolute path - `relative_path` - the path relative to the project root - `distribution_path` - the path to be distributed as \"\"\" for root , dirs , files in os . walk ( self . root ): relative_path = os . path . relpath ( root , self . root ) # First iteration if relative_path == '.' : relative_path = '' dirs [:] = sorted ( d for d in dirs if not ( self . ignore_directory ( d ) or self . path_is_excluded ( os . path . join ( relative_path , d ))) ) if self . ignore_files ( files ): continue for f in sorted ( files ): relative_file_path = os . path . join ( relative_path , f ) if self . include_path ( relative_file_path ): yield IncludedFile ( os . path . join ( root , f ), relative_file_path , self . get_distribution_path ( relative_file_path ) )","title":"recurse_project_files()"},{"location":"plugins/environment/","text":"Environment plugins \u00b6 Built-in \u00b6 Virtual \u00b6","title":"Environment"},{"location":"plugins/environment/#environment-plugins","text":"","title":"Environment plugins"},{"location":"plugins/environment/#built-in","text":"","title":"Built-in"},{"location":"plugins/environment/#virtual","text":"","title":"Virtual"},{"location":"plugins/publisher/","text":"Publisher plugins \u00b6 Built-in \u00b6 PyPI \u00b6","title":"Publisher"},{"location":"plugins/publisher/#publisher-plugins","text":"","title":"Publisher plugins"},{"location":"plugins/publisher/#built-in","text":"","title":"Built-in"},{"location":"plugins/publisher/#pypi","text":"","title":"PyPI"},{"location":"plugins/utilities/","text":"Plugin utilities \u00b6 Application \u00b6 The way output is displayed can be configured by users. abort ( self , message = '' , code = 1 , ** kwargs ) \u00b6 Terminate the program with the given return code. display_debug ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages that are not useful for most user experiences. display_error ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages indicating some unrecoverable error. display_info ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages conveying basic information. display_success ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages indicating some positive outcome. display_waiting ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages shown before potentially time consuming operations. display_warning ( self , message = '' , ** kwargs ) \u00b6 Meant to be used for messages conveying important information.","title":"Utilities"},{"location":"plugins/utilities/#plugin-utilities","text":"","title":"Plugin utilities"},{"location":"plugins/utilities/#hatchling.bridge.app.Application","text":"The way output is displayed can be configured by users.","title":"Application"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.abort","text":"Terminate the program with the given return code.","title":"abort()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_debug","text":"Meant to be used for messages that are not useful for most user experiences.","title":"display_debug()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_error","text":"Meant to be used for messages indicating some unrecoverable error.","title":"display_error()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_info","text":"Meant to be used for messages conveying basic information.","title":"display_info()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_success","text":"Meant to be used for messages indicating some positive outcome.","title":"display_success()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_waiting","text":"Meant to be used for messages shown before potentially time consuming operations.","title":"display_waiting()"},{"location":"plugins/utilities/#hatchling.bridge.app.Application.display_warning","text":"Meant to be used for messages conveying important information.","title":"display_warning()"},{"location":"plugins/version-scheme/","text":"Version scheme plugins \u00b6 Built-in \u00b6 Standard \u00b6","title":"Version scheme"},{"location":"plugins/version-scheme/#version-scheme-plugins","text":"","title":"Version scheme plugins"},{"location":"plugins/version-scheme/#built-in","text":"","title":"Built-in"},{"location":"plugins/version-scheme/#standard","text":"","title":"Standard"},{"location":"plugins/version-source/","text":"Version source plugins \u00b6 Built-in \u00b6 Regex \u00b6","title":"Version source"},{"location":"plugins/version-source/#version-source-plugins","text":"","title":"Version source plugins"},{"location":"plugins/version-source/#built-in","text":"","title":"Built-in"},{"location":"plugins/version-source/#regex","text":"","title":"Regex"}]}